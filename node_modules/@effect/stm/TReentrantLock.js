"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeLocks = exports.writeLocked = exports.writeLock = exports.withWriteLock = exports.withReadLock = exports.withLock = exports.releaseWrite = exports.releaseRead = exports.readLocks = exports.readLocked = exports.readLock = exports.make = exports.locked = exports.lock = exports.fiberWriteLocks = exports.fiberReadLocks = exports.acquireWrite = exports.acquireRead = exports.TReentrantLockTypeId = void 0;
var internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tReentrantLock"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 * @category symbols
 */
const TReentrantLockTypeId = internal.TReentrantLockTypeId;
/**
 * Acquires a read lock. The transaction will suspend until no other fiber is
 * holding a write lock. Succeeds with the number of read locks held by this
 * fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.TReentrantLockTypeId = TReentrantLockTypeId;
const acquireRead = internal.acquireRead;
/**
 * Acquires a write lock. The transaction will suspend until no other fibers
 * are holding read or write locks. Succeeds with the number of write locks
 * held by this fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.acquireRead = acquireRead;
const acquireWrite = internal.acquireWrite;
/**
 * Retrieves the number of acquired read locks for this fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.acquireWrite = acquireWrite;
const fiberReadLocks = internal.fiberReadLocks;
/**
 * Retrieves the number of acquired write locks for this fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.fiberReadLocks = fiberReadLocks;
const fiberWriteLocks = internal.fiberWriteLocks;
/**
 * Just a convenience method for applications that only need reentrant locks,
 * without needing a distinction between readers / writers.
 *
 * See `TReentrantLock.writeLock`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.fiberWriteLocks = fiberWriteLocks;
const lock = internal.lock;
/**
 * Determines if any fiber has a read or write lock.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.lock = lock;
const locked = internal.locked;
/**
 * Makes a new reentrant read/write lock.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.locked = locked;
const make = internal.make;
/**
 * Obtains a read lock in a scoped context.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.make = make;
const readLock = internal.readLock;
/**
 * Retrieves the total number of acquired read locks.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.readLock = readLock;
const readLocks = internal.readLocks;
/**
 * Determines if any fiber has a read lock.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.readLocks = readLocks;
const readLocked = internal.readLocked;
/**
 * Releases a read lock held by this fiber. Succeeds with the outstanding
 * number of read locks held by this fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.readLocked = readLocked;
const releaseRead = internal.releaseRead;
/**
 * Releases a write lock held by this fiber. Succeeds with the outstanding
 * number of write locks held by this fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.releaseRead = releaseRead;
const releaseWrite = internal.releaseWrite;
/**
 * Runs the specified workflow with a lock.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.releaseWrite = releaseWrite;
const withLock = internal.withLock;
/**
 * Runs the specified workflow with a read lock.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.withLock = withLock;
const withReadLock = internal.withReadLock;
/**
 * Runs the specified workflow with a write lock.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.withReadLock = withReadLock;
const withWriteLock = internal.withWriteLock;
/**
 * Obtains a write lock in a scoped context.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.withWriteLock = withWriteLock;
const writeLock = internal.writeLock;
/**
 * Determines if a write lock is held by some fiber.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.writeLock = writeLock;
const writeLocked = internal.writeLocked;
/**
 * Computes the number of write locks held by fibers.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.writeLocked = writeLocked;
const writeLocks = internal.writeLocks;
exports.writeLocks = writeLocks;
//# sourceMappingURL=TReentrantLock.js.map