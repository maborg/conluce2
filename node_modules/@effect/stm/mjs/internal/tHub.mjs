var _a, _b, _c, _d;
import { dual, identity } from "@effect/data/Function";
import * as HashSet from "@effect/data/HashSet";
import * as Option from "@effect/data/Option";
import * as RA from "@effect/data/ReadonlyArray";
import * as Effect from "@effect/io/Effect";
import * as core from "@effect/stm/internal/core";
import * as OpCodes from "@effect/stm/internal/opCodes/strategy";
import * as stm from "@effect/stm/internal/stm";
import * as tQueue from "@effect/stm/internal/tQueue";
import * as tRef from "@effect/stm/internal/tRef";
/** @internal */
const THubSymbolKey = "@effect/stm/THub";
/** @internal */
export const THubTypeId = /*#__PURE__*/Symbol.for(THubSymbolKey);
/** @internal */
export const makeNode = (head, subscribers, tail) => ({
  head,
  subscribers,
  tail
});
/** @internal */
class THubImpl {
  constructor(hubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.hubSize = hubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
    this[_a] = THubTypeId;
    this[_b] = tQueue.tEnqueueVariance;
    this.isShutdown = core.effect(journal => {
      const currentPublisherTail = tRef.unsafeGet(this.publisherTail, journal);
      return currentPublisherTail === undefined;
    });
    this.awaitShutdown = core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.unit : core.retry);
    this.size = core.withSTMRuntime(runtime => {
      const currentPublisherTail = tRef.unsafeGet(this.publisherTail, runtime.journal);
      if (currentPublisherTail === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      return core.succeed(tRef.unsafeGet(this.hubSize, runtime.journal));
    });
    this.isEmpty = core.map(this.size, size => size === 0);
    this.isFull = core.map(this.size, size => size === this.capacity());
    this.shutdown = core.effect(journal => {
      const currentPublisherTail = tRef.unsafeGet(this.publisherTail, journal);
      if (currentPublisherTail !== undefined) {
        tRef.unsafeSet(this.publisherTail, void 0, journal);
        const currentSubscribers = tRef.unsafeGet(this.subscribers, journal);
        HashSet.forEach(currentSubscribers, subscriber => {
          tRef.unsafeSet(subscriber, void 0, journal);
        });
        tRef.unsafeSet(this.subscribers, HashSet.empty(), journal);
      }
    });
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value) {
    return core.withSTMRuntime(runtime => {
      const currentPublisherTail = tRef.unsafeGet(this.publisherTail, runtime.journal);
      if (currentPublisherTail === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const currentSubscriberCount = tRef.unsafeGet(this.subscriberCount, runtime.journal);
      if (currentSubscriberCount === 0) {
        return core.succeed(true);
      }
      const currentHubSize = tRef.unsafeGet(this.hubSize, runtime.journal);
      if (currentHubSize < this.requestedCapacity) {
        const updatedPublisherTail = new tRef.TRefImpl(void 0);
        const updatedNode = makeNode(value, currentSubscriberCount, updatedPublisherTail);
        tRef.unsafeSet(currentPublisherTail, updatedNode, runtime.journal);
        tRef.unsafeSet(this.publisherTail, updatedPublisherTail, runtime.journal);
        tRef.unsafeSet(this.hubSize, currentHubSize + 1, runtime.journal);
        return core.succeed(true);
      }
      switch (this.strategy._tag) {
        case OpCodes.OP_BACKPRESSURE_STRATEGY:
          {
            return core.retry;
          }
        case OpCodes.OP_DROPPING_STRATEGY:
          {
            return core.succeed(false);
          }
        case OpCodes.OP_SLIDING_STRATEGY:
          {
            if (this.requestedCapacity > 0) {
              let currentPublisherHead = tRef.unsafeGet(this.publisherHead, runtime.journal);
              let loop = true;
              while (loop) {
                const node = tRef.unsafeGet(currentPublisherHead, runtime.journal);
                if (node === undefined) {
                  return core.retry;
                }
                const head = node.head;
                const tail = node.tail;
                if (head !== undefined) {
                  const updatedNode = makeNode(void 0, node.subscribers, node.tail);
                  tRef.unsafeSet(currentPublisherHead, updatedNode, runtime.journal);
                  tRef.unsafeSet(this.publisherHead, tail, runtime.journal);
                  loop = false;
                } else {
                  currentPublisherHead = tail;
                }
              }
            }
            const updatedPublisherTail = new tRef.TRefImpl(void 0);
            const updatedNode = makeNode(value, currentSubscriberCount, updatedPublisherTail);
            tRef.unsafeSet(currentPublisherTail, updatedNode, runtime.journal);
            tRef.unsafeSet(this.publisherTail, updatedPublisherTail, runtime.journal);
            return core.succeed(true);
          }
      }
    });
  }
  offerAll(iterable) {
    return core.map(stm.forEach(iterable, a => this.offer(a)), RA.every(identity));
  }
}
_a = THubTypeId, _b = tQueue.TEnqueueTypeId;
/** @internal */
class THubSubscriptionImpl {
  constructor(hubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.hubSize = hubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
    this[_c] = THubTypeId;
    this[_d] = tQueue.tDequeueVariance;
    this.isShutdown = core.effect(journal => {
      const currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, journal);
      return currentSubscriberHead === undefined;
    });
    this.awaitShutdown = core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.unit : core.retry);
    this.size = core.withSTMRuntime(runtime => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
      if (currentSubscriberHead === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      let loop = true;
      let size = 0;
      while (loop) {
        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
        if (node === undefined) {
          loop = false;
        } else {
          const head = node.head;
          const tail = node.tail;
          if (head !== undefined) {
            size = size + 1;
            if (size >= Number.MAX_SAFE_INTEGER) {
              loop = false;
            }
          }
          currentSubscriberHead = tail;
        }
      }
      return core.succeed(size);
    });
    this.isEmpty = core.map(this.size, size => size === 0);
    this.isFull = core.map(this.size, size => size === this.capacity());
    this.peek = core.withSTMRuntime(runtime => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
      if (currentSubscriberHead === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      let value = undefined;
      let loop = true;
      while (loop) {
        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
        if (node === undefined) {
          return core.retry;
        }
        const head = node.head;
        const tail = node.tail;
        if (head !== undefined) {
          value = head;
          loop = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
      return core.succeed(value);
    });
    this.peekOption = core.withSTMRuntime(runtime => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
      if (currentSubscriberHead === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      let value = Option.none();
      let loop = true;
      while (loop) {
        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
        if (node === undefined) {
          value = Option.none();
          loop = false;
        } else {
          const head = node.head;
          const tail = node.tail;
          if (head !== undefined) {
            value = Option.some(head);
            loop = false;
          } else {
            currentSubscriberHead = tail;
          }
        }
      }
      return core.succeed(value);
    });
    this.shutdown = core.effect(journal => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, journal);
      if (currentSubscriberHead !== undefined) {
        tRef.unsafeSet(this.subscriberHead, void 0, journal);
        let loop = true;
        while (loop) {
          const node = tRef.unsafeGet(currentSubscriberHead, journal);
          if (node === undefined) {
            loop = false;
          } else {
            const head = node.head;
            const tail = node.tail;
            if (head !== undefined) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size = tRef.unsafeGet(this.hubSize, journal);
                const updatedNode = makeNode(undefined, 0, tail);
                tRef.unsafeSet(currentSubscriberHead, updatedNode, journal);
                tRef.unsafeSet(this.publisherHead, tail, journal);
                tRef.unsafeSet(this.hubSize, size - 1, journal);
              } else {
                const updatedNode = makeNode(head, subscribers - 1, tail);
                tRef.unsafeSet(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail;
          }
        }
        const currentSubscriberCount = tRef.unsafeGet(this.subscriberCount, journal);
        tRef.unsafeSet(this.subscriberCount, currentSubscriberCount - 1, journal);
        tRef.unsafeSet(this.subscribers, HashSet.remove(tRef.unsafeGet(this.subscribers, journal), this.subscriberHead), journal);
      }
    });
    this.take = core.withSTMRuntime(runtime => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
      if (currentSubscriberHead === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      let value = undefined;
      let loop = true;
      while (loop) {
        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
        if (node === undefined) {
          return core.retry;
        }
        const head = node.head;
        const tail = node.tail;
        if (head !== undefined) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size = tRef.unsafeGet(this.hubSize, runtime.journal);
            const updatedNode = makeNode(void 0, 0, tail);
            tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
            tRef.unsafeSet(this.publisherHead, tail, runtime.journal);
            tRef.unsafeSet(this.hubSize, size - 1, runtime.journal);
          } else {
            const updatedNode = makeNode(head, subscribers - 1, tail);
            tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
          }
          tRef.unsafeSet(this.subscriberHead, tail, runtime.journal);
          value = head;
          loop = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
      return core.succeed(value);
    });
    this.takeAll = this.takeUpTo(Number.POSITIVE_INFINITY);
  }
  capacity() {
    return this.requestedCapacity;
  }
  takeUpTo(max) {
    return core.withSTMRuntime(runtime => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
      if (currentSubscriberHead === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max) {
        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
        if (node === undefined) {
          n = max;
        } else {
          const head = node.head;
          const tail = node.tail;
          if (head !== undefined) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size = tRef.unsafeGet(this.hubSize, runtime.journal);
              const updatedNode = makeNode(void 0, 0, tail);
              tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
              tRef.unsafeSet(this.publisherHead, tail, runtime.journal);
              tRef.unsafeSet(this.hubSize, size - 1, runtime.journal);
            } else {
              const updatedNode = makeNode(head, subscribers - 1, tail);
              tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
            }
            builder.push(head);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      tRef.unsafeSet(this.subscriberHead, currentSubscriberHead, runtime.journal);
      return core.succeed(builder);
    });
  }
}
_c = THubTypeId, _d = tQueue.TDequeueTypeId;
/** @internal */
const makeHub = (requestedCapacity, strategy) => core.flatMap(([empty, hubSize]) => core.map(([publisherHead, publisherTail, subscriberCount, subscribers]) => new THubImpl(hubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers))(stm.all([tRef.make(empty), tRef.make(empty), tRef.make(0), tRef.make(HashSet.empty())])))(stm.all([tRef.make(void 0), tRef.make(0)]));
const makeSubscription = (hubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => core.flatMap(currentPublisherTail => core.map(([subscriberHead]) => new THubSubscriptionImpl(hubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers))(stm.tap(([subscriberHead, _, currentSubscribers]) => tRef.set(HashSet.add(subscriberHead)(currentSubscribers))(subscribers))(stm.tap(([_, currentSubscriberCount]) => tRef.set(currentSubscriberCount + 1)(subscriberCount))(stm.all([tRef.make(currentPublisherTail), tRef.get(subscriberCount), tRef.get(subscribers)])))))(tRef.get(publisherTail));
/** @internal */
export const awaitShutdown = self => self.awaitShutdown;
/** @internal */
export const bounded = requestedCapacity => makeHub(requestedCapacity, tQueue.BackPressure);
/** @internal */
export const capacity = self => self.capacity();
/** @internal */
export const dropping = requestedCapacity => makeHub(requestedCapacity, tQueue.Dropping);
/** @internal */
export const isEmpty = self => self.isEmpty;
/** @internal */
export const isFull = self => self.isFull;
/** @internal */
export const isShutdown = self => self.isShutdown;
/** @internal */
export const publish = /*#__PURE__*/dual(2, (self, value) => self.offer(value));
/** @internal */
export const publishAll = /*#__PURE__*/dual(2, (self, iterable) => self.offerAll(iterable));
/** @internal */
export const size = self => self.size;
/** @internal */
export const shutdown = self => self.shutdown;
/** @internal */
export const sliding = requestedCapacity => makeHub(requestedCapacity, tQueue.Sliding);
/** @internal */
export const subscribe = self => makeSubscription(self.hubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);
/** @internal */
export const subscribeScoped = self => Effect.acquireRelease(subscribe(self), dequeue => tQueue.shutdown(dequeue));
/** @internal */
export const unbounded = () => makeHub(Number.MAX_SAFE_INTEGER, tQueue.Dropping);
//# sourceMappingURL=tHub.mjs.map