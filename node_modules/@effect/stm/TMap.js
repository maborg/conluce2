"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.values = exports.updateWith = exports.transformValuesSTM = exports.transformValues = exports.transformSTM = exports.transform = exports.toReadonlyMap = exports.toReadonlyArray = exports.toHashMap = exports.toChunk = exports.takeSomeSTM = exports.takeSome = exports.takeFirstSTM = exports.takeFirst = exports.size = exports.setIfAbsent = exports.set = exports.retainIfDiscard = exports.retainIf = exports.removeIfDiscard = exports.removeIf = exports.removeAll = exports.remove = exports.reduceWithIndexSTM = exports.reduceWithIndex = exports.reduceSTM = exports.reduce = exports.merge = exports.make = exports.keys = exports.isEmpty = exports.has = exports.getOrElse = exports.get = exports.fromIterable = exports.forEach = exports.findSTM = exports.findAllSTM = exports.findAll = exports.find = exports.empty = exports.TMapTypeId = void 0;
var internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tMap"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 * @category symbols
 */
const TMapTypeId = internal.TMapTypeId;
/**
 * Makes an empty `TMap`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.TMapTypeId = TMapTypeId;
const empty = internal.empty;
/**
 * Finds the key/value pair matching the specified predicate, and uses the
 * provided function to extract a value out of it.
 *
 * @since 1.0.0
 * @category elements
 */
exports.empty = empty;
const find = internal.find;
/**
 * Finds the key/value pair matching the specified predicate, and uses the
 * provided effectful function to extract a value out of it.
 *
 * @since 1.0.0
 * @category elements
 */
exports.find = find;
const findSTM = internal.findSTM;
/**
 * Finds all the key/value pairs matching the specified predicate, and uses
 * the provided function to extract values out them.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findSTM = findSTM;
const findAll = internal.findAll;
/**
 * Finds all the key/value pairs matching the specified predicate, and uses
 * the provided effectful function to extract values out of them..
 *
 * @since 1.0.0
 * @category elements
 */
exports.findAll = findAll;
const findAllSTM = internal.findAllSTM;
/**
 * Atomically performs transactional-effect for each binding present in map.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findAllSTM = findAllSTM;
const forEach = internal.forEach;
/**
 * Makes a new `TMap` initialized with provided iterable.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.forEach = forEach;
const fromIterable = internal.fromIterable;
/**
 * Retrieves value associated with given key.
 *
 * @since 1.0.0
 * @category elements
 */
exports.fromIterable = fromIterable;
const get = internal.get;
/**
 * Retrieves value associated with given key or default value, in case the key
 * isn't present.
 *
 * @since 1.0.0
 * @category elements
 */
exports.get = get;
const getOrElse = internal.getOrElse;
/**
 * Tests whether or not map contains a key.
 *
 * @since 1.0.0
 * @category elements
 */
exports.getOrElse = getOrElse;
const has = internal.has;
/**
 * Tests if the map is empty or not.
 *
 * @since 1.0.0
 * @category getters
 */
exports.has = has;
const isEmpty = internal.isEmpty;
/**
 * Collects all keys stored in map.
 *
 * @since 1.0.0
 * @category elements
 */
exports.isEmpty = isEmpty;
const keys = internal.keys;
/**
 * Makes a new `TMap` that is initialized with specified values.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.keys = keys;
const make = internal.make;
/**
 * If the key is not already associated with a value, stores the provided value,
 * otherwise merge the existing value with the new one using function `f` and
 * store the result.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.make = make;
const merge = internal.merge;
/**
 * Atomically folds using a pure function.
 *
 * @since 1.0.0
 * @category folding
 */
exports.merge = merge;
const reduce = internal.reduce;
/**
 * Atomically folds using a transactional function.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduce = reduce;
const reduceSTM = internal.reduceSTM;
/**
 * Atomically folds using a pure function.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduceSTM = reduceSTM;
const reduceWithIndex = internal.reduceWithIndex;
/**
 * Atomically folds using a transactional function.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduceWithIndex = reduceWithIndex;
const reduceWithIndexSTM = internal.reduceWithIndexSTM;
/**
 * Removes binding for given key.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.reduceWithIndexSTM = reduceWithIndexSTM;
const remove = internal.remove;
/**
 * Deletes all entries associated with the specified keys.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.remove = remove;
const removeAll = internal.removeAll;
/**
 * Removes bindings matching predicate and returns the removed entries.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.removeAll = removeAll;
const removeIf = internal.removeIf;
/**
 * Removes bindings matching predicate.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.removeIf = removeIf;
const removeIfDiscard = internal.removeIfDiscard;
/**
 * Retains bindings matching predicate and returns removed bindings.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.removeIfDiscard = removeIfDiscard;
const retainIf = internal.retainIf;
/**
 * Retains bindings matching predicate.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.retainIf = retainIf;
const retainIfDiscard = internal.retainIfDiscard;
/**
 * Stores new binding into the map.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.retainIfDiscard = retainIfDiscard;
const set = internal.set;
/**
 * Stores new binding in the map if it does not already exist.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.set = set;
const setIfAbsent = internal.setIfAbsent;
/**
 * Returns the number of bindings.
 *
 * @since 1.0.0
 * @category getters
 */
exports.setIfAbsent = setIfAbsent;
const size = internal.size;
/**
 * Takes the first matching value, or retries until there is one.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.size = size;
const takeFirst = internal.takeFirst;
/**
 * Takes the first matching value, or retries until there is one.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.takeFirst = takeFirst;
const takeFirstSTM = internal.takeFirstSTM;
/**
 * Takes all matching values, or retries until there is at least one.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.takeFirstSTM = takeFirstSTM;
const takeSome = internal.takeSome;
/**
 * Takes all matching values, or retries until there is at least one.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.takeSome = takeSome;
const takeSomeSTM = internal.takeSomeSTM;
/**
 * Collects all bindings into a `Chunk`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.takeSomeSTM = takeSomeSTM;
const toChunk = internal.toArray;
/**
 * Collects all bindings into a `HashMap`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toChunk = toChunk;
const toHashMap = internal.toHashMap;
/**
 * Collects all bindings into a `ReadonlyArray`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toHashMap = toHashMap;
const toReadonlyArray = internal.toReadonlyArray;
/**
 * Collects all bindings into a `ReadonlyMap`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toReadonlyArray = toReadonlyArray;
const toReadonlyMap = internal.toReadonlyMap;
/**
 * Atomically updates all bindings using a pure function.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.toReadonlyMap = toReadonlyMap;
const transform = internal.transform;
/**
 * Atomically updates all bindings using a transactional function.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.transform = transform;
const transformSTM = internal.transformSTM;
/**
 * Atomically updates all values using a pure function.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.transformSTM = transformSTM;
const transformValues = internal.transformValues;
/**
 * Atomically updates all values using a transactional function.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.transformValues = transformValues;
const transformValuesSTM = internal.transformValuesSTM;
/**
 * Updates the mapping for the specified key with the specified function,
 * which takes the current value of the key as an input, if it exists, and
 * either returns `Some` with a new value to indicate to update the value in
 * the map or `None` to remove the value from the map. Returns `Some` with the
 * updated value or `None` if the value was removed from the map.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.transformValuesSTM = transformValuesSTM;
const updateWith = internal.updateWith;
/**
 * Collects all values stored in map.
 *
 * @since 1.0.0
 * @category elements
 */
exports.updateWith = updateWith;
const values = internal.values;
exports.values = values;
//# sourceMappingURL=TMap.js.map