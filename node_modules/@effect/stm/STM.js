"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retryUntil = exports.retry = exports.replicateSTMDiscard = exports.replicateSTM = exports.replicate = exports.repeatWhile = exports.repeatUntil = exports.rejectSTM = exports.reject = exports.refineOrDieWith = exports.refineOrDie = exports.reduceRight = exports.reduceAll = exports.reduce = exports.provideSomeContext = exports.provideServiceSTM = exports.provideService = exports.provideContext = exports.partition = exports.orTry = exports.orElseSucceed = exports.orElseOptional = exports.orElseFail = exports.orElseEither = exports.orElse = exports.orDieWith = exports.orDie = exports.option = exports.none = exports.negate = exports.mergeAll = exports.merge = exports.matchSTM = exports.match = exports.mapInputContext = exports.mapError = exports.mapBoth = exports.mapAttempt = exports.map = exports.loop = exports.let = exports.iterate = exports.isSuccess = exports.isSTM = exports.isFailure = exports.interruptAs = exports.interrupt = exports.ignore = exports.if = exports.head = exports.gen = exports.fromOption = exports.fromEither = exports.forEach = exports.flipWith = exports.flip = exports.flatten = exports.flatMap = exports.firstSuccessOf = exports.filterOrFail = exports.filterOrElse = exports.filterOrDieMessage = exports.filterOrDie = exports.filterNot = exports.filter = exports.fiberId = exports.failSync = exports.fail = exports.exists = exports.every = exports.eventually = exports.ensuring = exports.either = exports.dieSync = exports.dieMessage = exports.die = exports.contextWithSTM = exports.contextWith = exports.context = exports.cond = exports.commitEither = exports.commit = exports.collectSTM = exports.collect = exports.check = exports.catchTags = exports.catchTag = exports.catchSome = exports.catchAll = exports.bindTo = exports.bind = exports.attempt = exports.asUnit = exports.asSomeError = exports.asSome = exports.as = exports.all = exports.acquireUseRelease = exports.STMTypeId = exports.Do = void 0;
exports.zipWith = exports.zipRight = exports.zipLeft = exports.zip = exports.whenSTM = exports.when = exports.validateFirst = exports.validateAll = exports.unsome = exports.unlessSTM = exports.unless = exports.unit = exports.try = exports.tapError = exports.tapBoth = exports.tap = exports.sync = exports.suspend = exports.summarized = exports.succeedSome = exports.succeedNone = exports.succeed = exports.some = exports.retryWhile = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var stm = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/stm"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category symbols
 */
const STMTypeId = core.STMTypeId;
/**
 * Returns `true` if the provided value is an `STM`, `false` otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
exports.STMTypeId = STMTypeId;
const isSTM = core.isSTM;
/**
 * Treats the specified `acquire` transaction as the acquisition of a
 * resource. The `acquire` transaction will be executed interruptibly. If it
 * is a success and is committed the specified `release` workflow will be
 * executed uninterruptibly as soon as the `use` workflow completes execution.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.isSTM = isSTM;
const acquireUseRelease = stm.acquireUseRelease;
/**
 * Runs all the provided transactional effects in sequence respecting the
 * structure provided in input.
 *
 * Supports multiple arguments, a single argument tuple / array or record /
 * struct.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.acquireUseRelease = acquireUseRelease;
const all = stm.all;
/**
 * Maps the success value of this effect to the specified constant value.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.all = all;
const as = stm.as;
/**
 * Maps the success value of this effect to an optional value.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.as = as;
const asSome = stm.asSome;
/**
 * Maps the error value of this effect to an optional value.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.asSome = asSome;
const asSomeError = stm.asSomeError;
/**
 * This function maps the success value of an `STM` to `void`. If the original
 * `STM` succeeds, the returned `STM` will also succeed. If the original `STM`
 * fails, the returned `STM` will fail with the same error.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.asSomeError = asSomeError;
const asUnit = stm.asUnit;
/**
 * Creates an `STM` value from a partial (but pure) function.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.asUnit = asUnit;
const attempt = stm.attempt;
/**
 * Recovers from all errors.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.attempt = attempt;
const catchAll = core.catchAll;
/**
 * Recovers from some or all of the error cases.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.catchAll = catchAll;
const catchSome = stm.catchSome;
/**
 * Recovers from the specified tagged error.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.catchSome = catchSome;
const catchTag = stm.catchTag;
/**
 * Recovers from multiple tagged errors.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.catchTag = catchTag;
const catchTags = stm.catchTags;
/**
 * Checks the condition, and if it's true, returns unit, otherwise, retries.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.catchTags = catchTags;
const check = stm.check;
/**
 * Simultaneously filters and maps the value produced by this effect.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.check = check;
const collect = stm.collect;
/**
 * Simultaneously filters and maps the value produced by this effect.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.collect = collect;
const collectSTM = stm.collectSTM;
/**
 * Commits this transaction atomically.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.collectSTM = collectSTM;
const commit = core.commit;
/**
 * Commits this transaction atomically, regardless of whether the transaction
 * is a success or a failure.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.commit = commit;
const commitEither = stm.commitEither;
/**
 * Similar to Either.cond, evaluate the predicate, return the given A as
 * success if predicate returns true, and the given E as error otherwise
 *
 * @since 1.0.0
 * @category constructors
 */
exports.commitEither = commitEither;
const cond = stm.cond;
/**
 * Retrieves the environment inside an stm.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.cond = cond;
const context = core.context;
/**
 * Accesses the environment of the transaction to perform a transaction.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.context = context;
const contextWith = core.contextWith;
/**
 * Accesses the environment of the transaction to perform a transaction.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.contextWith = contextWith;
const contextWithSTM = core.contextWithSTM;
/**
 * Transforms the environment being provided to this effect with the specified
 * function.
 *
 * @since 1.0.0
 * @category context
 */
exports.contextWithSTM = contextWithSTM;
const mapInputContext = core.mapInputContext;
/**
 * Fails the transactional effect with the specified defect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.mapInputContext = mapInputContext;
const die = core.die;
/**
 * Kills the fiber running the effect with a `Cause.RuntimeException` that
 * contains the specified message.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.die = die;
const dieMessage = core.dieMessage;
/**
 * Fails the transactional effect with the specified lazily evaluated defect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.dieMessage = dieMessage;
const dieSync = core.dieSync;
/**
 * Converts the failure channel into an `Either`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.dieSync = dieSync;
const either = stm.either;
/**
 * Executes the specified finalization transaction whether or not this effect
 * succeeds. Note that as with all STM transactions, if the full transaction
 * fails, everything will be rolled back.
 *
 * @since 1.0.0
 * @category finalization
 */
exports.either = either;
const ensuring = core.ensuring;
/**
 * Returns an effect that ignores errors and runs repeatedly until it
 * eventually succeeds.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.ensuring = ensuring;
const eventually = stm.eventually;
/**
 * Determines whether all elements of the `Iterable<A>` satisfy the effectual
 * predicate.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.eventually = eventually;
const every = stm.every;
/**
 * Determines whether any element of the `Iterable[A]` satisfies the effectual
 * predicate `f`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.every = every;
const exists = stm.exists;
/**
 * Fails the transactional effect with the specified error.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.exists = exists;
const fail = core.fail;
/**
 * Fails the transactional effect with the specified lazily evaluated error.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fail = fail;
const failSync = core.failSync;
/**
 * Returns the fiber id of the fiber committing the transaction.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.failSync = failSync;
const fiberId = stm.fiberId;
/**
 * Filters the collection using the specified effectual predicate.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fiberId = fiberId;
const filter = stm.filter;
/**
 * Filters the collection using the specified effectual predicate, removing
 * all elements that satisfy the predicate.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.filter = filter;
const filterNot = stm.filterNot;
/**
 * Dies with specified defect if the predicate fails.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterNot = filterNot;
const filterOrDie = stm.filterOrDie;
/**
 * Dies with a `Cause.RuntimeException` having the specified  message if the
 * predicate fails.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterOrDie = filterOrDie;
const filterOrDieMessage = stm.filterOrDieMessage;
/**
 * Supplies `orElse` if the predicate fails.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterOrDieMessage = filterOrDieMessage;
const filterOrElse = stm.filterOrElse;
/**
 * Fails with the specified error if the predicate fails.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterOrElse = filterOrElse;
const filterOrFail = stm.filterOrFail;
/**
 * Feeds the value produced by this effect to the specified function, and then
 * runs the returned effect as well to produce its results.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.filterOrFail = filterOrFail;
const flatMap = core.flatMap;
/**
 * Flattens out a nested `STM` effect.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.flatMap = flatMap;
const flatten = stm.flatten;
/**
 * Flips the success and failure channels of this transactional effect. This
 * allows you to use all methods on the error channel, possibly before
 * flipping back.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.flatten = flatten;
const flip = stm.flip;
/**
 * Swaps the error/value parameters, applies the function `f` and flips the
 * parameters back
 *
 * @since 1.0.0
 * @category mutations
 */
exports.flip = flip;
const flipWith = stm.flipWith;
/**
 * Folds over the `STM` effect, handling both failure and success, but not
 * retry.
 *
 * @since 1.0.0
 * @category folding
 */
exports.flipWith = flipWith;
const match = stm.match;
/**
 * Effectfully folds over the `STM` effect, handling both failure and success.
 *
 * @since 1.0.0
 * @category folding
 */
exports.match = match;
const matchSTM = core.matchSTM;
/**
 * Applies the function `f` to each element of the `Iterable<A>` and returns
 * a transactional effect that produces a new `Chunk<A2>`.
 *
 * @since 1.0.0
 * @category traversing
 */
exports.matchSTM = matchSTM;
const forEach = stm.forEach;
/**
 * Lifts an `Either` into a `STM`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.forEach = forEach;
const fromEither = stm.fromEither;
/**
 * Lifts an `Option` into a `STM`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromEither = fromEither;
const fromOption = stm.fromOption;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.fromOption = fromOption;
const gen = stm.gen;
/**
 * Returns a successful effect with the head of the list if the list is
 * non-empty or fails with the error `None` if the list is empty.
 *
 * @since 1.0.0
 * @category getters
 */
exports.gen = gen;
const head = stm.head;
exports.head = head;
const if_ = stm.if_;
exports.if = if_;
/**
 * Returns a new effect that ignores the success or failure of this effect.
 *
 * @since 1.0.0
 * @category mutations
 */
const ignore = stm.ignore;
/**
 * Interrupts the fiber running the effect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.ignore = ignore;
const interrupt = core.interrupt;
/**
 * Interrupts the fiber running the effect with the specified `FiberId`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.interrupt = interrupt;
const interruptAs = core.interruptAs;
/**
 * Returns whether this transactional effect is a failure.
 *
 * @since 1.0.0
 * @category getters
 */
exports.interruptAs = interruptAs;
const isFailure = stm.isFailure;
/**
 * Returns whether this transactional effect is a success.
 *
 * @since 1.0.0
 * @category getters
 */
exports.isFailure = isFailure;
const isSuccess = stm.isSuccess;
/**
 * Iterates with the specified transactional function. The moral equivalent
 * of:
 *
 * ```ts
 * const s = initial
 *
 * while (cont(s)) {
 *   s = body(s)
 * }
 *
 * return s
 * ```
 *
 * @since 1.0.0
 * @category constructors
 */
exports.isSuccess = isSuccess;
const iterate = stm.iterate;
/**
 * Loops with the specified transactional function, collecting the results
 * into a list. The moral equivalent of:
 *
 * ```ts
 * const as = []
 * let s  = initial
 *
 * while (cont(s)) {
 *   as.push(body(s))
 *   s  = inc(s)
 * }
 *
 * return as
 * ```
 *
 * @since 1.0.0
 * @category constructors
 */
exports.iterate = iterate;
const loop = stm.loop;
/**
 * Maps the value produced by the effect.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.loop = loop;
const map = core.map;
/**
 * Maps the value produced by the effect with the specified function that may
 * throw exceptions but is otherwise pure, translating any thrown exceptions
 * into typed failed effects.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.map = map;
const mapAttempt = stm.mapAttempt;
/**
 * Returns an `STM` effect whose failure and success channels have been mapped
 * by the specified pair of functions, `f` and `g`.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapAttempt = mapAttempt;
const mapBoth = stm.mapBoth;
/**
 * Maps from one error type to another.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapBoth = mapBoth;
const mapError = stm.mapError;
/**
 * Returns a new effect where the error channel has been merged into the
 * success channel to their common combined type.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.mapError = mapError;
const merge = stm.merge;
/**
 * Merges an `Iterable<STM>` to a single `STM`, working sequentially.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.merge = merge;
const mergeAll = stm.mergeAll;
/**
 * Returns a new effect where boolean value of this effect is negated.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.mergeAll = mergeAll;
const negate = stm.negate;
/**
 * Requires the option produced by this value to be `None`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.negate = negate;
const none = stm.none;
/**
 * Converts the failure channel into an `Option`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.none = none;
const option = stm.option;
/**
 * Translates `STM` effect failure into death of the fiber, making all
 * failures unchecked and not a part of the type of the effect.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.option = option;
const orDie = stm.orDie;
/**
 * Keeps none of the errors, and terminates the fiber running the `STM` effect
 * with them, using the specified function to convert the `E` into a defect.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orDie = orDie;
const orDieWith = stm.orDieWith;
/**
 * Tries this effect first, and if it fails or retries, tries the other
 * effect.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orDieWith = orDieWith;
const orElse = stm.orElse;
/**
 * Returns a transactional effect that will produce the value of this effect
 * in left side, unless it fails or retries, in which case, it will produce
 * the value of the specified effect in right side.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orElse = orElse;
const orElseEither = stm.orElseEither;
/**
 * Tries this effect first, and if it fails or retries, fails with the
 * specified error.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orElseEither = orElseEither;
const orElseFail = stm.orElseFail;
/**
 * Returns an effect that will produce the value of this effect, unless it
 * fails with the `None` value, in which case it will produce the value of the
 * specified effect.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orElseFail = orElseFail;
const orElseOptional = stm.orElseOptional;
/**
 * Tries this effect first, and if it fails or retries, succeeds with the
 * specified value.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orElseOptional = orElseOptional;
const orElseSucceed = stm.orElseSucceed;
/**
 * Tries this effect first, and if it enters retry, then it tries the other
 * effect. This is an equivalent of Haskell's orElse.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orElseSucceed = orElseSucceed;
const orTry = core.orTry;
/**
 * Feeds elements of type `A` to a function `f` that returns an effect.
 * Collects all successes and failures in a tupled fashion.
 *
 * @since 1.0.0
 * @category traversing
 */
exports.orTry = orTry;
const partition = stm.partition;
/**
 * Provides the transaction its required environment, which eliminates its
 * dependency on `R`.
 *
 * @since 1.0.0
 * @category context
 */
exports.partition = partition;
const provideContext = stm.provideContext;
/**
 * Splits the context into two parts, providing one part using the
 * specified layer and leaving the remainder `R0`.
 *
 * @since 1.0.0
 * @category context
 */
exports.provideContext = provideContext;
const provideSomeContext = stm.provideSomeContext;
/**
 * Provides the effect with the single service it requires. If the transactional
 * effect requires more than one service use `provideEnvironment` instead.
 *
 * @since 1.0.0
 * @category context
 */
exports.provideSomeContext = provideSomeContext;
const provideService = stm.provideService;
/**
 * Provides the effect with the single service it requires. If the transactional
 * effect requires more than one service use `provideEnvironment` instead.
 *
 * @since 1.0.0
 * @category context
 */
exports.provideService = provideService;
const provideServiceSTM = stm.provideServiceSTM;
/**
 * Folds an `Iterable<A>` using an effectual function f, working sequentially
 * from left to right.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.provideServiceSTM = provideServiceSTM;
const reduce = stm.reduce;
/**
 * Reduces an `Iterable<STM>` to a single `STM`, working sequentially.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.reduce = reduce;
const reduceAll = stm.reduceAll;
/**
 * Folds an `Iterable<A>` using an effectual function f, working sequentially
 * from right to left.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.reduceAll = reduceAll;
const reduceRight = stm.reduceRight;
/**
 * Keeps some of the errors, and terminates the fiber with the rest.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.reduceRight = reduceRight;
const refineOrDie = stm.refineOrDie;
/**
 * Keeps some of the errors, and terminates the fiber with the rest, using the
 * specified function to convert the `E` into a `Throwable`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.refineOrDie = refineOrDie;
const refineOrDieWith = stm.refineOrDieWith;
/**
 * Fail with the returned value if the `PartialFunction` matches, otherwise
 * continue with our held value.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.refineOrDieWith = refineOrDieWith;
const reject = stm.reject;
/**
 * Continue with the returned computation if the specified partial function
 * matches, translating the successful match into a failure, otherwise continue
 * with our held value.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.reject = reject;
const rejectSTM = stm.rejectSTM;
/**
 * Repeats this `STM` effect until its result satisfies the specified
 * predicate.
 *
 * **WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will
 * consume a thread until it completes (it cannot yield). This is because STM
 * describes a single atomic transaction which must either complete, retry or
 * fail a transaction before yielding back to the Effect runtime.
 *   - Use `retryUntil` instead if you don't need to maintain transaction
 *     state for repeats.
 *   - Ensure repeating the STM effect will eventually satisfy the predicate.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.rejectSTM = rejectSTM;
const repeatUntil = stm.repeatUntil;
/**
 * Repeats this `STM` effect while its result satisfies the specified
 * predicate.
 *
 * **WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will
 * consume a thread until it completes (it cannot yield). This is because STM
 * describes a single atomic transaction which must either complete, retry or
 * fail a transaction before yielding back to the Effect runtime.
 *   - Use `retryWhile` instead if you don't need to maintain transaction
 *     state for repeats.
 *   - Ensure repeating the STM effect will eventually not satisfy the
 *     predicate.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.repeatUntil = repeatUntil;
const repeatWhile = stm.repeatWhile;
/**
 * Replicates the given effect n times. If 0 or negative numbers are given, an
 * empty `Chunk` will be returned.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.repeatWhile = repeatWhile;
const replicate = stm.replicate;
/**
 * Performs this transaction the specified number of times and collects the
 * results.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.replicate = replicate;
const replicateSTM = stm.replicateSTM;
/**
 * Performs this transaction the specified number of times, discarding the
 * results.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.replicateSTM = replicateSTM;
const replicateSTMDiscard = stm.replicateSTMDiscard;
/**
 * Abort and retry the whole transaction when any of the underlying
 * transactional variables have changed.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.replicateSTMDiscard = replicateSTMDiscard;
const retry = core.retry;
/**
 * Filters the value produced by this effect, retrying the transaction until
 * the predicate returns `true` for the value.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.retry = retry;
const retryUntil = stm.retryUntil;
/**
 * Filters the value produced by this effect, retrying the transaction while
 * the predicate returns `true` for the value.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.retryUntil = retryUntil;
const retryWhile = stm.retryWhile;
/**
 * Converts an option on values into an option on errors.
 *
 * @since 1.0.0
 * @category getters
 */
exports.retryWhile = retryWhile;
const some = stm.some;
/**
 * Returns an `STM` effect that succeeds with the specified value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.some = some;
const succeed = core.succeed;
/**
 * Returns an effect with the empty value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.succeed = succeed;
const succeedNone = stm.succeedNone;
/**
 * Returns an effect with the optional value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.succeedNone = succeedNone;
const succeedSome = stm.succeedSome;
/**
 * Summarizes a `STM` effect by computing a provided value before and after
 * execution, and then combining the values to produce a summary, together
 * with the result of execution.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.succeedSome = succeedSome;
const summarized = stm.summarized;
/**
 * Suspends creation of the specified transaction lazily.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.summarized = summarized;
const suspend = stm.suspend;
/**
 * Returns an `STM` effect that succeeds with the specified lazily evaluated
 * value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.suspend = suspend;
const sync = core.sync;
/**
 * "Peeks" at the success of transactional effect.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.sync = sync;
const tap = stm.tap;
/**
 * "Peeks" at both sides of an transactional effect.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.tap = tap;
const tapBoth = stm.tapBoth;
/**
 * "Peeks" at the error of the transactional effect.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.tapBoth = tapBoth;
const tapError = stm.tapError;
exports.tapError = tapError;
const try_ = stm.try_;
exports.try = try_;
/**
 * The moral equivalent of `if (!p) exp`
 *
 * @since 1.0.0
 * @category mutations
 */
const unless = stm.unless;
/**
 * The moral equivalent of `if (!p) exp` when `p` has side-effects
 *
 * @since 1.0.0
 * @category mutations
 */
exports.unless = unless;
const unlessSTM = stm.unlessSTM;
/**
 * Converts an option on errors into an option on values.
 *
 * @since 1.0.0
 * @category getters
 */
exports.unlessSTM = unlessSTM;
const unsome = stm.unsome;
/**
 * Returns an `STM` effect that succeeds with `Unit`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.unsome = unsome;
const unit = stm.unit;
/**
 * Feeds elements of type `A` to `f` and accumulates all errors in error
 * channel or successes in success channel.
 *
 * This combinator is lossy meaning that if there are errors all successes
 * will be lost. To retain all information please use `STM.partition`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.unit = unit;
const validateAll = stm.validateAll;
/**
 * Feeds elements of type `A` to `f` until it succeeds. Returns first success
 * or the accumulation of all errors.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.validateAll = validateAll;
const validateFirst = stm.validateFirst;
/**
 * The moral equivalent of `if (p) exp`.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.validateFirst = validateFirst;
const when = stm.when;
/**
 * The moral equivalent of `if (p) exp` when `p` has side-effects.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.when = when;
const whenSTM = stm.whenSTM;
/**
 * Sequentially zips this value with the specified one.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.whenSTM = whenSTM;
const zip = core.zip;
/**
 * Sequentially zips this value with the specified one, discarding the second
 * element of the tuple.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zip = zip;
const zipLeft = core.zipLeft;
/**
 * Sequentially zips this value with the specified one, discarding the first
 * element of the tuple.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipLeft = zipLeft;
const zipRight = core.zipRight;
/**
 * Sequentially zips this value with the specified one, combining the values
 * using the specified combiner function.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipRight = zipRight;
const zipWith = core.zipWith;
/**
 * This function takes an iterable of `STM` values and returns a new
 * `STM` value that represents the first `STM` value in the iterable
 * that succeeds. If all of the `Effect` values in the iterable fail, then
 * the resulting `STM` value will fail as well.
 *
 * This function is sequential, meaning that the `STM` values in the
 * iterable will be executed in sequence, and the first one that succeeds
 * will determine the outcome of the resulting `STM` value.
 *
 * @param effects - The iterable of `STM` values to evaluate.
 *
 * @returns A new `STM` value that represents the first successful
 * `STM` value in the iterable, or a failed `STM` value if all of the
 * `STM` values in the iterable fail.
 *
 * @since 1.0.0
 * @category elements
 */
exports.zipWith = zipWith;
const firstSuccessOf = effects => suspend(() => {
  const list = Chunk.fromIterable(effects);
  if (!Chunk.isNonEmpty(list)) {
    return dieSync(() => Cause.IllegalArgumentException(`Received an empty collection of effects`));
  }
  return Chunk.reduce(Chunk.tailNonEmpty(list), Chunk.headNonEmpty(list), (left, right) => orElse(left, () => right));
});
/**
 * @category do notation
 * @since 1.0.0
 */
exports.firstSuccessOf = firstSuccessOf;
const Do = /*#__PURE__*/succeed({});
/**
 * @category do notation
 * @since 1.0.0
 */
exports.Do = Do;
const bind = stm.bind;
exports.bind = bind;
const let_ = stm.let_;
exports.let = let_;
/**
 * @category do notation
 * @since 1.0.0
 */
const bindTo = stm.bindTo;
exports.bindTo = bindTo;
//# sourceMappingURL=STM.js.map