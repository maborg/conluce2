"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.union = exports.transformSTM = exports.transform = exports.toReadonlySet = exports.toReadonlyArray = exports.toHashSet = exports.toChunk = exports.takeSomeSTM = exports.takeSome = exports.takeFirstSTM = exports.takeFirst = exports.size = exports.retainIfDiscard = exports.retainIf = exports.removeIfDiscard = exports.removeIf = exports.removeAll = exports.remove = exports.reduceSTM = exports.reduce = exports.make = exports.isEmpty = exports.intersection = exports.has = exports.fromIterable = exports.forEach = exports.empty = exports.difference = exports.add = exports.TSetTypeId = void 0;
var _Function = /*#__PURE__*/require("@effect/data/Function");
var HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/HashSet"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var tMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tMap"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const TSetSymbolKey = "@effect/stm/TSet";
/** @internal */
const TSetTypeId = /*#__PURE__*/Symbol.for(TSetSymbolKey);
/** @internal */
exports.TSetTypeId = TSetTypeId;
const tSetVariance = {
  _A: _ => _
};
/** @internal */
class TSetImpl {
  constructor(tMap) {
    this.tMap = tMap;
    this[_a] = tSetVariance;
  }
}
_a = TSetTypeId;
/** @internal */
const add = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => tMap.set(self.tMap, value, void 0));
/** @internal */
exports.add = add;
const difference = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => core.flatMap(toHashSet(other), values => removeIfDiscard(self, value => HashSet.has(values, value))));
/** @internal */
exports.difference = difference;
const empty = () => fromIterable([]);
/** @internal */
exports.empty = empty;
const forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, void 0, (_, value) => f(value)));
/** @internal */
exports.forEach = forEach;
const fromIterable = iterable => core.map(tMap.fromIterable(Array.from(iterable).map(a => [a, void 0])), tMap => new TSetImpl(tMap));
/** @internal */
exports.fromIterable = fromIterable;
const has = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => tMap.has(self.tMap, value));
/** @internal */
exports.has = has;
const intersection = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => core.flatMap(toHashSet(other), values => retainIfDiscard(value => HashSet.has(value)(values))(self)));
/** @internal */
exports.intersection = intersection;
const isEmpty = self => tMap.isEmpty(self.tMap);
/** @internal */
exports.isEmpty = isEmpty;
const make = (...elements) => fromIterable(elements);
/** @internal */
exports.make = make;
const reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => tMap.reduceWithIndex(self.tMap, zero, (acc, _, key) => f(acc, key)));
/** @internal */
exports.reduce = reduce;
const reduceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => tMap.reduceWithIndexSTM(self.tMap, zero, (acc, _, key) => f(acc, key)));
/** @internal */
exports.reduceSTM = reduceSTM;
const remove = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => tMap.remove(self.tMap, value));
/** @internal */
exports.remove = remove;
const removeAll = /*#__PURE__*/(0, _Function.dual)(2, (self, iterable) => tMap.removeAll(self.tMap, iterable));
/** @internal */
exports.removeAll = removeAll;
const removeIf = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(RA.map(entry => entry[0]))(tMap.removeIf(self.tMap, key => predicate(key))));
/** @internal */
exports.removeIf = removeIf;
const removeIfDiscard = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => tMap.removeIfDiscard(self.tMap, key => predicate(key)));
/** @internal */
exports.removeIfDiscard = removeIfDiscard;
const retainIf = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(RA.map(entry => entry[0]))(tMap.retainIf(self.tMap, key => predicate(key))));
/** @internal */
exports.retainIf = retainIf;
const retainIfDiscard = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => tMap.retainIfDiscard(self.tMap, key => predicate(key)));
/** @internal */
exports.retainIfDiscard = retainIfDiscard;
const size = self => core.map(toChunk(self), chunk => chunk.length);
/** @internal */
exports.size = size;
const takeFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeFirst(self.tMap, key => pf(key)));
/** @internal */
exports.takeFirst = takeFirst;
const takeFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeFirstSTM(self.tMap, key => pf(key)));
/** @internal */
exports.takeFirstSTM = takeFirstSTM;
const takeSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeSome(self.tMap, key => pf(key)));
/** @internal */
exports.takeSome = takeSome;
const takeSomeSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeSomeSTM(self.tMap, key => pf(key)));
/** @internal */
exports.takeSomeSTM = takeSomeSTM;
const toChunk = self => tMap.keys(self.tMap);
/** @internal */
exports.toChunk = toChunk;
const toHashSet = self => reduce(self, HashSet.empty(), (acc, value) => HashSet.add(value)(acc));
/** @internal */
exports.toHashSet = toHashSet;
const toReadonlyArray = self => reduce(self, [], (acc, value) => [...acc, value]);
/** @internal */
exports.toReadonlyArray = toReadonlyArray;
const toReadonlySet = self => core.map(toReadonlyArray(self), values => new Set(values));
/** @internal */
exports.toReadonlySet = toReadonlySet;
const transform = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => tMap.transform(self.tMap, (key, value) => [f(key), value]));
/** @internal */
exports.transform = transform;
const transformSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => tMap.transformSTM(self.tMap, (key, value) => core.map(f(key), a => [a, value])));
/** @internal */
exports.transformSTM = transformSTM;
const union = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => forEach(other, value => add(self, value)));
exports.union = union;
//# sourceMappingURL=tSet.js.map