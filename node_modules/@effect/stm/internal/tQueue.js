"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unbounded = exports.takeUpTo = exports.takeN = exports.takeBetween = exports.takeAll = exports.take = exports.tEnqueueVariance = exports.tDequeueVariance = exports.sliding = exports.size = exports.shutdown = exports.seek = exports.poll = exports.peekOption = exports.peek = exports.offerAll = exports.offer = exports.isTQueue = exports.isTEnqueue = exports.isTDequeue = exports.isShutdown = exports.isFull = exports.isEmpty = exports.dropping = exports.capacity = exports.bounded = exports.awaitShutdown = exports.TEnqueueTypeId = exports.TDequeueTypeId = exports.Sliding = exports.Dropping = exports.BackPressure = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/opCodes/strategy"));
var stm = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/stm"));
var tRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tRef"));
var STM = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/STM"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a, _b;
const TEnqueueSymbolKey = "@effect/stm/TQueue/TEnqueue";
/** @internal */
const TEnqueueTypeId = /*#__PURE__*/Symbol.for(TEnqueueSymbolKey);
exports.TEnqueueTypeId = TEnqueueTypeId;
const TDequeueSymbolKey = "@effect/stm/TQueue/TDequeue";
/** @internal */
const TDequeueTypeId = /*#__PURE__*/Symbol.for(TDequeueSymbolKey);
/** @internal */
exports.TDequeueTypeId = TDequeueTypeId;
const BackPressure = {
  _tag: OpCodes.OP_BACKPRESSURE_STRATEGY
};
/** @internal */
exports.BackPressure = BackPressure;
const Dropping = {
  _tag: OpCodes.OP_DROPPING_STRATEGY
};
/** @internal */
exports.Dropping = Dropping;
const Sliding = {
  _tag: OpCodes.OP_SLIDING_STRATEGY
};
/** @internal */
exports.Sliding = Sliding;
const tDequeueVariance = {
  _Out: _ => _
};
/** @internal */
exports.tDequeueVariance = tDequeueVariance;
const tEnqueueVariance = {
  _In: _ => _
};
exports.tEnqueueVariance = tEnqueueVariance;
class TQueueImpl {
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this[_a] = tDequeueVariance;
    this[_b] = tEnqueueVariance;
    this.size = core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return STM.interruptAs(runtime.fiberId);
      }
      return core.succeed(queue.length);
    });
    this.isFull = core.map(this.size, size => size === this.requestedCapacity);
    this.isEmpty = core.map(this.size, size => size === 0);
    this.shutdown = core.withSTMRuntime(runtime => {
      tRef.unsafeSet(this.ref, void 0, runtime.journal);
      return stm.unit;
    });
    this.isShutdown = core.effect(journal => {
      const queue = tRef.unsafeGet(this.ref, journal);
      return queue === undefined;
    });
    this.awaitShutdown = core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.unit : core.retry);
    this.peek = core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const head = queue[0];
      if (head === undefined) {
        return core.retry;
      }
      return core.succeed(head);
    });
    this.peekOption = core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      return core.succeed(Option.fromNullable(queue[0]));
    });
    this.take = core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const dequeued = queue.shift();
      if (dequeued === undefined) {
        return core.retry;
      }
      tRef.unsafeSet(this.ref, queue, runtime.journal);
      return core.succeed(dequeued);
    });
    this.takeAll = core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      tRef.unsafeSet(this.ref, [], runtime.journal);
      return core.succeed(queue);
    });
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value) {
    return core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(runtime.journal)(this.ref);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        tRef.unsafeSet(this.ref, queue, runtime.journal);
        return core.succeed(true);
      }
      switch (this.strategy._tag) {
        case OpCodes.OP_BACKPRESSURE_STRATEGY:
          {
            return core.retry;
          }
        case OpCodes.OP_DROPPING_STRATEGY:
          {
            return core.succeed(false);
          }
        case OpCodes.OP_SLIDING_STRATEGY:
          {
            const dequeued = queue.shift();
            if (dequeued === undefined) {
              return core.succeed(true);
            }
            queue.push(value);
            tRef.unsafeSet(this.ref, queue, runtime.journal);
            return core.succeed(true);
          }
      }
    });
  }
  offerAll(iterable) {
    return core.withSTMRuntime(runtime => {
      const as = Array.from(iterable);
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      if (queue.length + as.length <= this.requestedCapacity) {
        tRef.unsafeSet(this.ref, [...queue, ...as], runtime.journal);
        return core.succeed(true);
      }
      switch (this.strategy._tag) {
        case OpCodes.OP_BACKPRESSURE_STRATEGY:
          {
            return core.retry;
          }
        case OpCodes.OP_DROPPING_STRATEGY:
          {
            const forQueue = as.slice(0, this.requestedCapacity - queue.length);
            tRef.unsafeSet(this.ref, [...queue, ...forQueue], runtime.journal);
            return core.succeed(false);
          }
        case OpCodes.OP_SLIDING_STRATEGY:
          {
            const forQueue = as.slice(0, this.requestedCapacity - queue.length);
            const toDrop = queue.length + forQueue.length - this.requestedCapacity;
            const newQueue = queue.slice(toDrop);
            tRef.unsafeSet(this.ref, [...newQueue, ...forQueue], runtime.journal);
            return core.succeed(true);
          }
      }
    });
  }
  takeUpTo(max) {
    return core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const [toTake, remaining] = Chunk.splitAt(Chunk.unsafeFromArray(queue), max);
      tRef.unsafeSet(this.ref, Array.from(remaining), runtime.journal);
      return core.succeed(Array.from(toTake));
    });
  }
}
_a = TDequeueTypeId, _b = TEnqueueTypeId;
/** @internal */
const isTQueue = u => {
  return isTEnqueue(u) && isTDequeue(u);
};
/** @internal */
exports.isTQueue = isTQueue;
const isTEnqueue = u => {
  return typeof u === "object" && u != null && TEnqueueTypeId in u;
};
/** @internal */
exports.isTEnqueue = isTEnqueue;
const isTDequeue = u => {
  return typeof u === "object" && u != null && TDequeueTypeId in u;
};
/** @internal */
exports.isTDequeue = isTDequeue;
const awaitShutdown = self => self.awaitShutdown;
/** @internal */
exports.awaitShutdown = awaitShutdown;
const bounded = requestedCapacity => makeQueue(requestedCapacity, BackPressure);
/** @internal */
exports.bounded = bounded;
const capacity = self => {
  return self.capacity();
};
/** @internal */
exports.capacity = capacity;
const dropping = requestedCapacity => makeQueue(requestedCapacity, Dropping);
/** @internal */
exports.dropping = dropping;
const isEmpty = self => self.isEmpty;
/** @internal */
exports.isEmpty = isEmpty;
const isFull = self => self.isFull;
/** @internal */
exports.isFull = isFull;
const isShutdown = self => self.isShutdown;
/** @internal */
exports.isShutdown = isShutdown;
const offer = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => self.offer(value));
/** @internal */
exports.offer = offer;
const offerAll = /*#__PURE__*/(0, _Function.dual)(2, (self, iterable) => self.offerAll(iterable));
/** @internal */
exports.offerAll = offerAll;
const peek = self => self.peek;
/** @internal */
exports.peek = peek;
const peekOption = self => self.peekOption;
/** @internal */
exports.peekOption = peekOption;
const poll = self => core.map(RA.head)(self.takeUpTo(1));
/** @internal */
exports.poll = poll;
const seek = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => seekLoop(self, predicate));
exports.seek = seek;
const seekLoop = (self, predicate) => core.flatMap(self.take, a => predicate(a) ? core.succeed(a) : seekLoop(self, predicate));
/** @internal */
const shutdown = self => self.shutdown;
/** @internal */
exports.shutdown = shutdown;
const size = self => self.size;
/** @internal */
exports.size = size;
const sliding = requestedCapacity => makeQueue(requestedCapacity, Sliding);
/** @internal */
exports.sliding = sliding;
const take = self => self.take;
/** @internal */
exports.take = take;
const takeAll = self => self.takeAll;
/** @internal */
exports.takeAll = takeAll;
const takeBetween = /*#__PURE__*/(0, _Function.dual)(3, (self, min, max) => stm.suspend(() => {
  const takeRemainder = (min, max, acc) => {
    if (max < min) {
      return core.succeed(acc);
    }
    return core.flatMap(taken => {
      const remaining = min - taken.length;
      if (remaining === 1) {
        return core.map(a => Chunk.append(a)(Chunk.appendAll(Chunk.unsafeFromArray(taken))(acc)))(self.take);
      }
      if (remaining > 1) {
        return core.flatMap(a => takeRemainder(remaining - 1, max - taken.length - 1, Chunk.append(a)(Chunk.appendAll(Chunk.unsafeFromArray(taken))(acc))))(self.take);
      }
      return core.succeed(Chunk.appendAll(Chunk.unsafeFromArray(taken))(acc));
    })(self.takeUpTo(max));
  };
  return core.map(takeRemainder(min, max, Chunk.empty()), c => Array.from(c));
}));
/** @internal */
exports.takeBetween = takeBetween;
const takeN = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => takeBetween(n, n)(self));
/** @internal */
exports.takeN = takeN;
const takeUpTo = /*#__PURE__*/(0, _Function.dual)(2, (self, max) => self.takeUpTo(max));
/** @internal */
exports.takeUpTo = takeUpTo;
const unbounded = () => makeQueue(Number.MAX_SAFE_INTEGER, Dropping);
exports.unbounded = unbounded;
const makeQueue = (requestedCapacity, strategy) => core.map(tRef.make([]), ref => new TQueueImpl(ref, requestedCapacity, strategy));
//# sourceMappingURL=tQueue.js.map