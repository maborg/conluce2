"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whenSTM = exports.when = exports.validateFirst = exports.validateAll = exports.unsome = exports.unlessSTM = exports.unless = exports.unit = exports.try_ = exports.tapError = exports.tapBoth = exports.tap = exports.suspend = exports.summarized = exports.succeedSome = exports.succeedNone = exports.some = exports.retryWhile = exports.retryUntil = exports.replicateSTMDiscard = exports.replicateSTM = exports.replicate = exports.repeatWhile = exports.repeatUntil = exports.rejectSTM = exports.reject = exports.refineOrDieWith = exports.refineOrDie = exports.reduceRight = exports.reduceAll = exports.reduce = exports.provideSomeContext = exports.provideServiceSTM = exports.provideService = exports.provideContext = exports.partition = exports.orElseSucceed = exports.orElseOptional = exports.orElseFail = exports.orElseEither = exports.orElse = exports.orDieWith = exports.orDie = exports.option = exports.none = exports.negate = exports.mergeAll = exports.merge = exports.match = exports.mapError = exports.mapBoth = exports.mapAttempt = exports.loop = exports.let_ = exports.iterate = exports.isSuccess = exports.isFailure = exports.ignore = exports.if_ = exports.head = exports.gen = exports.fromOption = exports.fromEither = exports.forEach = exports.flipWith = exports.flip = exports.flatten = exports.filterOrFail = exports.filterOrElse = exports.filterOrDieMessage = exports.filterOrDie = exports.filterNot = exports.filter = exports.fiberId = exports.exists = exports.every = exports.eventually = exports.either = exports.cond = exports.commitEither = exports.collectSTM = exports.collect = exports.check = exports.catchTags = exports.catchTag = exports.catchSome = exports.bindTo = exports.bind = exports.attempt = exports.asUnit = exports.asSomeError = exports.asSome = exports.as = exports.all = exports.acquireUseRelease = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Context"));
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Predicate"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var effectCore = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/internal/core"));
var SingleShotGen = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/internal/singleShotGen"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var Journal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/stm/journal"));
var STMState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/stm/stmState"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const acquireUseRelease = /*#__PURE__*/(0, _Function.dual)(3, (acquire, use, release) => Effect.uninterruptibleMask(restore => {
  let state = STMState.running;
  return Effect.matchCauseEffect({
    onFailure: cause => {
      if (STMState.isDone(state) && Exit.isSuccess(state.exit)) {
        return Effect.matchCauseEffect({
          onFailure: cause2 => Effect.failCause(Cause.parallel(cause, cause2)),
          onSuccess: () => Effect.failCause(cause)
        })(release(state.exit.value));
      }
      return Effect.failCause(cause);
    },
    onSuccess: a => Effect.matchCauseEffect({
      onFailure: cause => Effect.matchCauseEffect({
        onFailure: cause2 => Effect.failCause(Cause.parallel(cause, cause2)),
        onSuccess: () => Effect.failCause(cause)
      })(release(a)),
      onSuccess: a2 => Effect.as(a2)(release(a))
    })(restore(use(a)))
  })(restore(core.unsafeAtomically(acquire, exit => {
    state = STMState.done(exit);
  }, () => {
    state = STMState.interrupted;
  })));
}));
/** @internal */
exports.acquireUseRelease = acquireUseRelease;
const as = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => core.map(() => value)(self));
/** @internal */
exports.as = as;
const asSome = self => core.map(Option.some)(self);
/** @internal */
exports.asSome = asSome;
const asSomeError = self => mapError(Option.some)(self);
/** @internal */
exports.asSomeError = asSomeError;
const asUnit = self => core.map(_Function.constVoid)(self);
/** @internal */
exports.asUnit = asUnit;
const attempt = evaluate => suspend(() => {
  try {
    return core.succeed(evaluate());
  } catch (defect) {
    return core.fail(defect);
  }
});
exports.attempt = attempt;
const bind = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, f) => core.flatMap(self, k => core.map(f(k), a => ({
  ...k,
  [tag]: a
}))));
/* @internal */
exports.bind = bind;
const bindTo = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => core.map(self, a => ({
  [tag]: a
})));
/* @internal */
exports.bindTo = bindTo;
const let_ = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, f) => core.map(self, k => ({
  ...k,
  [tag]: f(k)
})));
/** @internal */
exports.let_ = let_;
const catchSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.catchAll(self, e => Option.getOrElse(pf(e), () => core.fail(e))));
exports.catchSome = catchSome;
const catchTag = /*#__PURE__*/(0, _Function.dual)(3, (self, k, f) => core.catchAll(self, e => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return core.fail(e);
}));
/** @internal */
exports.catchTag = catchTag;
const catchTags = /*#__PURE__*/(0, _Function.dual)(2, (self, cases) => core.catchAll(self, e => {
  const keys = Object.keys(cases);
  if ("_tag" in e && keys.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return core.fail(e);
}));
/** @internal */
exports.catchTags = catchTags;
const check = predicate => suspend(() => predicate() ? unit : core.retry);
/** @internal */
exports.check = check;
const collect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => collectSTM(self, a => Option.map(pf(a), core.succeed)));
/** @internal */
exports.collect = collect;
const collectSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.matchSTM(self, {
  onFailure: core.fail,
  onSuccess: a => {
    const option = pf(a);
    return Option.isSome(option) ? option.value : core.retry;
  }
}));
/** @internal */
exports.collectSTM = collectSTM;
const commitEither = self => Effect.flatten(core.commit(either(self)));
/** @internal */
exports.commitEither = commitEither;
const cond = (predicate, error, result) => {
  return suspend(() => predicate() ? core.sync(result) : core.failSync(error));
};
/** @internal */
exports.cond = cond;
const either = self => match(self, {
  onFailure: Either.left,
  onSuccess: Either.right
});
/** @internal */
exports.either = either;
const eventually = self => core.matchSTM(self, {
  onFailure: () => eventually(self),
  onSuccess: core.succeed
});
/** @internal */
exports.eventually = eventually;
const every = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => core.flatMap(core.sync(() => iterable[Symbol.iterator]()), iterator => {
  const loop = suspend(() => {
    const next = iterator.next();
    if (next.done) {
      return core.succeed(true);
    }
    return core.flatMap(bool => bool ? loop : core.succeed(bool))(predicate(next.value));
  });
  return loop;
}));
/** @internal */
exports.every = every;
const exists = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => core.flatMap(core.sync(() => iterable[Symbol.iterator]()), iterator => {
  const loop = suspend(() => {
    const next = iterator.next();
    if (next.done) {
      return core.succeed(false);
    }
    return core.flatMap(predicate(next.value), bool => bool ? core.succeed(bool) : loop);
  });
  return loop;
}));
/** @internal */
exports.exists = exists;
const fiberId = /*#__PURE__*/core.effect((_, fiberId) => fiberId);
/** @internal */
exports.fiberId = fiberId;
const filter = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => core.zipWith(predicate(curr), (as, p) => {
  if (p) {
    as.push(curr);
    return as;
  }
  return as;
})(acc), core.succeed([])));
/** @internal */
exports.filter = filter;
const filterNot = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => filter(iterable, a => negate(predicate(a))));
/** @internal */
exports.filterNot = filterNot;
const filterOrDie = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, defect) => filterOrElse(self, predicate, () => core.dieSync(defect)));
/** @internal */
exports.filterOrDie = filterOrDie;
const filterOrDieMessage = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, message) => filterOrElse(self, predicate, () => core.dieMessage(message)));
/** @internal */
exports.filterOrDieMessage = filterOrDieMessage;
const filterOrElse = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, orElse) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : orElse(a)));
/** @internal */
exports.filterOrElse = filterOrElse;
const filterOrFail = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, orFailWith) => filterOrElse(self, predicate, a => core.failSync(() => orFailWith(a))));
/** @internal */
exports.filterOrFail = filterOrFail;
const flatten = self => core.flatMap(self, _Function.identity);
/** @internal */
exports.flatten = flatten;
const flip = self => core.matchSTM(self, {
  onFailure: core.succeed,
  onSuccess: core.fail
});
/** @internal */
exports.flip = flip;
const flipWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flip(f(flip(self))));
/** @internal */
exports.flipWith = flipWith;
const match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => core.matchSTM(self, {
  onFailure: e => core.succeed(onFailure(e)),
  onSuccess: a => core.succeed(onSuccess(a))
}));
/** @internal */
exports.match = match;
const forEach = /*#__PURE__*/(0, _Function.dual)(args => predicate.isIterable(args[0]), (iterable, f, options) => {
  if (options?.discard) {
    return core.flatMap(iterator => {
      const loop = suspend(() => {
        const next = iterator.next();
        if (next.done) {
          return unit;
        }
        return core.flatMap(() => loop)(f(next.value));
      });
      return loop;
    })(core.sync(() => iterable[Symbol.iterator]()));
  }
  return suspend(() => RA.fromIterable(iterable).reduce((acc, curr) => core.zipWith(acc, f(curr), (array, elem) => {
    array.push(elem);
    return array;
  }), core.succeed([])));
});
/** @internal */
exports.forEach = forEach;
const fromEither = either => {
  switch (either._tag) {
    case "Left":
      {
        return core.fail(either.left);
      }
    case "Right":
      {
        return core.succeed(either.right);
      }
  }
};
/** @internal */
exports.fromEither = fromEither;
const fromOption = option => Option.match(option, {
  onNone: () => core.fail(Option.none()),
  onSome: core.succeed
});
/** @internal */
exports.fromOption = fromOption;
class STMGen {
  constructor(value) {
    this.value = value;
  }
  [Symbol.iterator]() {
    return new SingleShotGen.SingleShotGen(this);
  }
}
const adapter = function () {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new STMGen(x);
};
/**
 * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)
 * @internal
 */
const gen = f => suspend(() => {
  const iterator = f(adapter);
  const state = iterator.next();
  const run = state => state.done ? core.succeed(state.value) : core.flatMap(state.value.value, val => run(iterator.next(val)));
  return run(state);
});
/** @internal */
exports.gen = gen;
const head = self => core.matchSTM({
  onFailure: e => core.fail(Option.some(e)),
  onSuccess: a => {
    const i = a[Symbol.iterator]();
    const res = i.next();
    if (res.done) {
      return core.fail(Option.none());
    } else {
      return core.succeed(res.value);
    }
  }
})(self);
/** @internal */
exports.head = head;
const if_ = /*#__PURE__*/(0, _Function.dual)(args => typeof args[0] === "boolean" || core.isSTM(args[0]), (self, {
  onFalse,
  onTrue
}) => {
  if (typeof self === "boolean") {
    return self ? onTrue : onFalse;
  }
  return core.flatMap(self, bool => bool ? onTrue : onFalse);
});
/** @internal */
exports.if_ = if_;
const ignore = self => match(self, {
  onFailure: () => unit,
  onSuccess: () => unit
});
/** @internal */
exports.ignore = ignore;
const isFailure = self => match(self, {
  onFailure: _Function.constTrue,
  onSuccess: _Function.constFalse
});
/** @internal */
exports.isFailure = isFailure;
const isSuccess = self => match(self, {
  onFailure: _Function.constFalse,
  onSuccess: _Function.constTrue
});
/** @internal */
exports.isSuccess = isSuccess;
const iterate = (initial, options) => iterateLoop(initial, options.while, options.body);
exports.iterate = iterate;
const iterateLoop = (initial, cont, body) => {
  if (cont(initial)) {
    return core.flatMap(z => iterateLoop(z, cont, body))(body(initial));
  }
  return core.succeed(initial);
};
/** @internal */
const loop = (initial, options) => options.discard ? loopDiscardLoop(initial, options.while, options.step, options.body) : core.map(loopLoop(initial, options.while, options.step, options.body), a => Array.from(a));
exports.loop = loop;
const loopLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return core.flatMap(a => core.map(Chunk.append(a))(loopLoop(inc(initial), cont, inc, body)))(body(initial));
  }
  return core.succeed(Chunk.empty());
};
const loopDiscardLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return core.flatMap(() => loopDiscardLoop(inc(initial), cont, inc, body))(body(initial));
  }
  return unit;
};
/** @internal */
const mapAttempt = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchSTM(self, {
  onFailure: e => core.fail(e),
  onSuccess: a => attempt(() => f(a))
}));
/** @internal */
exports.mapAttempt = mapAttempt;
const mapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => core.matchSTM(self, {
  onFailure: e => core.fail(onFailure(e)),
  onSuccess: a => core.succeed(onSuccess(a))
}));
/** @internal */
exports.mapBoth = mapBoth;
const mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchSTM(self, {
  onFailure: e => core.fail(f(e)),
  onSuccess: core.succeed
}));
/** @internal */
exports.mapError = mapError;
const merge = self => core.matchSTM(self, {
  onFailure: e => core.succeed(e),
  onSuccess: core.succeed
});
/** @internal */
exports.merge = merge;
const mergeAll = /*#__PURE__*/(0, _Function.dual)(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => core.zipWith(curr, f)(acc), core.succeed(zero))));
/** @internal */
exports.mergeAll = mergeAll;
const negate = self => core.map(b => !b)(self);
/** @internal */
exports.negate = negate;
const none = self => core.matchSTM(self, {
  onFailure: e => core.fail(Option.some(e)),
  onSuccess: Option.match({
    onNone: () => unit,
    onSome: () => core.fail(Option.none())
  })
});
/** @internal */
exports.none = none;
const option = self => match(self, {
  onFailure: () => Option.none(),
  onSuccess: Option.some
});
/** @internal */
exports.option = option;
const orDie = self => orDieWith(_Function.identity)(self);
/** @internal */
exports.orDie = orDie;
const orDieWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.catchAll(core.die)(mapError(f)(self)));
/** @internal */
exports.orDieWith = orDieWith;
const orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => core.flatMap(core.effect(journal => Journal.prepareResetJournal(journal)), reset => core.catchAll(() => core.flatMap(core.sync(reset), that))(core.orTry(self, () => core.flatMap(core.sync(reset), that)))));
/** @internal */
exports.orElse = orElse;
const orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => orElse(core.map(self, Either.left), () => core.map(that(), Either.right)));
/** @internal */
exports.orElseEither = orElseEither;
const orElseFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => orElse(self, () => core.failSync(error)));
/** @internal */
exports.orElseFail = orElseFail;
const orElseOptional = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => core.catchAll(self, Option.match({
  onNone: that,
  onSome: e => core.fail(Option.some(e))
})));
/** @internal */
exports.orElseOptional = orElseOptional;
const orElseSucceed = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => orElse(self, () => core.sync(value)));
/** @internal */
exports.orElseSucceed = orElseSucceed;
const provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, env) => core.mapInputContext(self, _ => env));
/** @internal */
exports.provideContext = provideContext;
const provideSomeContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => core.mapInputContext(self, parent => Context.merge(parent, context)));
/** @internal */
exports.provideSomeContext = provideSomeContext;
const provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, resource) => provideServiceSTM(self, tag, core.succeed(resource)));
/** @internal */
exports.provideService = provideService;
const provideServiceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, stm) => core.contextWithSTM(env => core.flatMap(stm, service => provideContext(self, Context.add(env, tag, service)))));
/** @internal */
exports.provideServiceSTM = provideServiceSTM;
const reduce = /*#__PURE__*/(0, _Function.dual)(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => core.flatMap(s => f(s, curr))(acc), core.succeed(zero))));
/** @internal */
exports.reduce = reduce;
const reduceAll = /*#__PURE__*/(0, _Function.dual)(3, (iterable, initial, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => core.zipWith(curr, f)(acc), initial)));
/** @internal */
exports.reduceAll = reduceAll;
const reduceRight = /*#__PURE__*/(0, _Function.dual)(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduceRight((acc, curr) => core.flatMap(s => f(s, curr))(acc), core.succeed(zero))));
/** @internal */
exports.reduceRight = reduceRight;
const refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => refineOrDieWith(self, pf, _Function.identity));
/** @internal */
exports.refineOrDie = refineOrDie;
const refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => core.catchAll(self, e => Option.match(pf(e), {
  onNone: () => core.die(f(e)),
  onSome: core.fail
})));
/** @internal */
exports.refineOrDieWith = refineOrDieWith;
const reject = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => rejectSTM(self, a => Option.map(pf(a), core.fail)));
/** @internal */
exports.reject = reject;
const rejectSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.flatMap(self, a => Option.match(pf(a), {
  onNone: () => core.succeed(a),
  onSome: core.flatMap(core.fail)
})));
/** @internal */
exports.rejectSTM = rejectSTM;
const repeatUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => repeatUntilLoop(self, predicate));
exports.repeatUntil = repeatUntil;
const repeatUntilLoop = (self, predicate) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : repeatUntilLoop(self, predicate));
/** @internal */
const repeatWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => repeatWhileLoop(self, predicate));
exports.repeatWhile = repeatWhile;
const repeatWhileLoop = (self, predicate) => core.flatMap(self, a => predicate(a) ? repeatWhileLoop(self, predicate) : core.succeed(a));
/** @internal */
const replicate = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => Array.from({
  length: n
}, () => self));
/** @internal */
exports.replicate = replicate;
const replicateSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => all(replicate(self, n)));
/** @internal */
exports.replicateSTM = replicateSTM;
const replicateSTMDiscard = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => all(replicate(self, n), {
  discard: true
}));
/** @internal */
exports.replicateSTMDiscard = replicateSTMDiscard;
const retryUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.matchSTM(self, {
  onFailure: core.fail,
  onSuccess: a => predicate(a) ? core.succeed(a) : core.retry
}));
/** @internal */
exports.retryUntil = retryUntil;
const retryWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.matchSTM(self, {
  onFailure: core.fail,
  onSuccess: a => !predicate(a) ? core.succeed(a) : core.retry
}));
/** @internal */
exports.retryWhile = retryWhile;
const partition = /*#__PURE__*/(0, _Function.dual)(2, (elements, f) => core.map(as => effectCore.partitionMap(as, _Function.identity))(forEach(elements, a => either(f(a)))));
/** @internal */
exports.partition = partition;
const some = self => core.matchSTM(self, {
  onFailure: e => core.fail(Option.some(e)),
  onSuccess: Option.match({
    onNone: () => core.fail(Option.none()),
    onSome: core.succeed
  })
});
/* @internal */
exports.some = some;
const all = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach(input, _Function.identity, options);
  } else if (options?.discard) {
    return forEach(Object.values(input), _Function.identity, options);
  }
  return core.map(forEach(Object.entries(input), ([_, e]) => core.map(e, a => [_, a])), values => {
    const res = {};
    for (const [k, v] of values) {
      ;
      res[k] = v;
    }
    return res;
  });
};
/** @internal */
exports.all = all;
const succeedNone = /*#__PURE__*/core.succeed( /*#__PURE__*/Option.none());
/** @internal */
exports.succeedNone = succeedNone;
const succeedSome = value => core.succeed(Option.some(value));
/** @internal */
exports.succeedSome = succeedSome;
const summarized = /*#__PURE__*/(0, _Function.dual)(3, (self, summary, f) => core.flatMap(summary, start => core.flatMap(self, value => core.map(summary, end => [f(start, end), value]))));
/** @internal */
exports.summarized = summarized;
const suspend = evaluate => flatten(core.sync(evaluate));
/** @internal */
exports.suspend = suspend;
const tap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.flatMap(self, a => as(f(a), a)));
/** @internal */
exports.tap = tap;
const tapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => core.matchSTM(self, {
  onFailure: e => core.zipRight(core.fail(e))(onFailure(e)),
  onSuccess: a => as(a)(onSuccess(a))
}));
/** @internal */
exports.tapBoth = tapBoth;
const tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchSTM(self, {
  onFailure: e => core.zipRight(f(e), core.fail(e)),
  onSuccess: core.succeed
}));
/** @internal */
exports.tapError = tapError;
const try_ = arg => {
  const evaluate = typeof arg === "function" ? arg : arg.try;
  return suspend(() => {
    try {
      return core.succeed(evaluate());
    } catch (error) {
      return core.fail("catch" in arg ? arg.catch(error) : error);
    }
  });
};
/** @internal */
exports.try_ = try_;
const unit = /*#__PURE__*/core.succeed(void 0);
/** @internal */
exports.unit = unit;
const unless = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => suspend(() => predicate() ? succeedNone : asSome(self)));
/** @internal */
exports.unless = unless;
const unlessSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.flatMap(predicate, bool => bool ? succeedNone : asSome(self)));
/** @internal */
exports.unlessSTM = unlessSTM;
const unsome = self => core.matchSTM(self, {
  onFailure: Option.match({
    onNone: () => core.succeed(Option.none()),
    onSome: core.fail
  }),
  onSuccess: a => core.succeed(Option.some(a))
});
/** @internal */
exports.unsome = unsome;
const validateAll = /*#__PURE__*/(0, _Function.dual)(2, (elements, f) => core.flatMap(partition(elements, f), ([errors, values]) => RA.isNonEmptyArray(errors) ? core.fail(errors) : core.succeed(values)));
/** @internal */
exports.validateAll = validateAll;
const validateFirst = /*#__PURE__*/(0, _Function.dual)(2, (elements, f) => flip(forEach(elements, a => flip(f(a)))));
/** @internal */
exports.validateFirst = validateFirst;
const when = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => suspend(() => predicate() ? asSome(self) : succeedNone));
/** @internal */
exports.when = when;
const whenSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.flatMap(predicate, bool => bool ? asSome(self) : succeedNone));
exports.whenSTM = whenSTM;
//# sourceMappingURL=stm.js.map