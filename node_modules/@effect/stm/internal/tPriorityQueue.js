"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toReadonlyArray = exports.toChunk = exports.takeUpTo = exports.takeOption = exports.takeAll = exports.take = exports.size = exports.retainIf = exports.removeIf = exports.peekOption = exports.peek = exports.offerAll = exports.offer = exports.make = exports.isNonEmpty = exports.isEmpty = exports.fromIterable = exports.empty = exports.TPriorityQueueTypeId = exports.TPriorityQueueImpl = void 0;
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var ReadonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var SortedMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/SortedMap"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var tRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tRef"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const TPriorityQueueSymbolKey = "@effect/stm/TPriorityQueue";
/** @internal */
const TPriorityQueueTypeId = /*#__PURE__*/Symbol.for(TPriorityQueueSymbolKey);
/** @internal */
exports.TPriorityQueueTypeId = TPriorityQueueTypeId;
const tPriorityQueueVariance = {
  _A: _ => _
};
/** @internal */
class TPriorityQueueImpl {
  constructor(ref) {
    this.ref = ref;
    this[_a] = tPriorityQueueVariance;
  }
}
exports.TPriorityQueueImpl = TPriorityQueueImpl;
_a = TPriorityQueueTypeId;
/** @internal */
const empty = order => core.map(ref => new TPriorityQueueImpl(ref))(tRef.make(SortedMap.empty(order)));
/** @internal */
exports.empty = empty;
const fromIterable = order => iterable => core.map(ref => new TPriorityQueueImpl(ref))(tRef.make(Array.from(iterable).reduce((map, value) => SortedMap.set(value, Option.match({
  onNone: () => ReadonlyArray.of(value),
  onSome: ReadonlyArray.prepend(value)
})(SortedMap.get(value)(map)))(map), SortedMap.empty(order))));
/** @internal */
exports.fromIterable = fromIterable;
const isEmpty = self => core.map(tRef.get(self.ref), SortedMap.isEmpty);
/** @internal */
exports.isEmpty = isEmpty;
const isNonEmpty = self => core.map(tRef.get(self.ref), SortedMap.isNonEmpty);
/** @internal */
exports.isNonEmpty = isNonEmpty;
const make = order => (...elements) => fromIterable(order)(elements);
/** @internal */
exports.make = make;
const offer = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => tRef.update(self.ref, map => SortedMap.set(map, value, Option.match(SortedMap.get(map, value), {
  onNone: () => ReadonlyArray.of(value),
  onSome: ReadonlyArray.prepend(value)
}))));
/** @internal */
exports.offer = offer;
const offerAll = /*#__PURE__*/(0, _Function.dual)(2, (self, values) => tRef.update(self.ref, map => Array.from(values).reduce((map, value) => SortedMap.set(map, value, Option.match(SortedMap.get(map, value), {
  onNone: () => ReadonlyArray.of(value),
  onSome: ReadonlyArray.prepend(value)
})), map)));
/** @internal */
exports.offerAll = offerAll;
const peek = self => core.withSTMRuntime(runtime => {
  const map = tRef.unsafeGet(self.ref, runtime.journal);
  return Option.match(SortedMap.headOption(map), {
    onNone: () => core.retry,
    onSome: elements => core.succeed(elements[0])
  });
});
/** @internal */
exports.peek = peek;
const peekOption = self => tRef.modify(self.ref, map => [Option.map(SortedMap.headOption(map), elements => elements[0]), map]);
/** @internal */
exports.peekOption = peekOption;
const removeIf = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => retainIf(self, a => !predicate(a)));
/** @internal */
exports.removeIf = removeIf;
const retainIf = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => tRef.update(self.ref, map => SortedMap.reduce(map, SortedMap.empty(SortedMap.getOrder(map)), (map, value, key) => {
  const filtered = ReadonlyArray.filter(value, predicate);
  return filtered.length > 0 ? SortedMap.set(map, key, filtered) : SortedMap.remove(map, key);
})));
/** @internal */
exports.retainIf = retainIf;
const size = self => tRef.modify(self.ref, map => [SortedMap.reduce(map, 0, (n, as) => n + as.length), map]);
/** @internal */
exports.size = size;
const take = self => core.withSTMRuntime(runtime => {
  const map = tRef.unsafeGet(self.ref, runtime.journal);
  return Option.match(SortedMap.headOption(map), {
    onNone: () => core.retry,
    onSome: values => {
      const head = values[1][0];
      const tail = values[1].slice(1);
      tRef.unsafeSet(self.ref, tail.length > 0 ? SortedMap.set(map, head, tail) : SortedMap.remove(map, head), runtime.journal);
      return core.succeed(head);
    }
  });
});
/** @internal */
exports.take = take;
const takeAll = self => tRef.modify(self.ref, map => {
  const builder = [];
  for (const entry of map) {
    builder.push(...entry[1]);
  }
  return [builder, SortedMap.empty(SortedMap.getOrder(map))];
});
/** @internal */
exports.takeAll = takeAll;
const takeOption = self => core.effect(journal => {
  const map = tRef.unsafeGet(journal)(self.ref);
  return Option.match(SortedMap.headOption(map), {
    onNone: () => Option.none(),
    onSome: ([key, value]) => {
      const tail = value.slice(1);
      tRef.unsafeSet(self.ref, tail.length > 0 ? SortedMap.set(map, key, tail) : SortedMap.remove(map, key), journal);
      return Option.some(value[0]);
    }
  });
});
/** @internal */
exports.takeOption = takeOption;
const takeUpTo = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => tRef.modify(self.ref, map => {
  const builder = [];
  const iterator = map[Symbol.iterator]();
  let updated = map;
  let index = 0;
  let next;
  while ((next = iterator.next()) && !next.done && index < n) {
    const [key, value] = next.value;
    const [left, right] = ReadonlyArray.splitAt(n - index)(value);
    builder.push(...left);
    if (right.length > 0) {
      updated = SortedMap.set(updated, key, right);
    } else {
      updated = SortedMap.remove(updated, key);
    }
    index = index + left.length;
  }
  return [builder, updated];
}));
/** @internal */
exports.takeUpTo = takeUpTo;
const toChunk = self => tRef.modify(self.ref, map => {
  const builder = [];
  for (const entry of map) {
    builder.push(...entry[1]);
  }
  return [builder, map];
});
/** @internal */
exports.toChunk = toChunk;
const toReadonlyArray = self => tRef.modify(self.ref, map => {
  const builder = [];
  for (const entry of map) {
    builder.push(...entry[1]);
  }
  return [builder, map];
});
exports.toReadonlyArray = toReadonlyArray;
//# sourceMappingURL=tPriorityQueue.js.map