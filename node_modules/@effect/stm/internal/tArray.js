"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSTM = exports.update = exports.transformSTM = exports.transform = exports.toArray = exports.someSTM = exports.some = exports.size = exports.reduceSTM = exports.reduceOptionSTM = exports.reduceOption = exports.reduce = exports.minOption = exports.maxOption = exports.make = exports.lastOption = exports.headOption = exports.get = exports.fromIterable = exports.forEach = exports.findLastSTM = exports.findLastIndexFrom = exports.findLastIndex = exports.findLast = exports.findFirstSTM = exports.findFirstIndexWhereSTM = exports.findFirstIndexWhereFromSTM = exports.findFirstIndexWhereFrom = exports.findFirstIndexWhere = exports.findFirstIndexFrom = exports.findFirstIndex = exports.findFirst = exports.everySTM = exports.every = exports.empty = exports.countSTM = exports.count = exports.contains = exports.collectFirstSTM = exports.collectFirst = exports.TArrayTypeId = exports.TArrayImpl = void 0;
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var Order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Order"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var stm = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/stm"));
var tRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tRef"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const TArraySymbolKey = "@effect/stm/TArray";
/** @internal */
const TArrayTypeId = /*#__PURE__*/Symbol.for(TArraySymbolKey);
/** @internal */
exports.TArrayTypeId = TArrayTypeId;
const tArrayVariance = {
  _A: _ => _
};
/** @internal */
class TArrayImpl {
  constructor(chunk) {
    this.chunk = chunk;
    this[_a] = tArrayVariance;
  }
}
exports.TArrayImpl = TArrayImpl;
_a = TArrayTypeId;
/** @internal */
const collectFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => collectFirstSTM(self, a => Option.map(core.succeed)(pf(a))));
/** @internal */
exports.collectFirst = collectFirst;
const collectFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.withSTMRuntime(runtime => {
  let index = 0;
  let result = Option.none();
  while (Option.isNone(result) && index < self.chunk.length) {
    const element = tRef.unsafeGet(runtime.journal)(self.chunk[index]);
    const option = pf(element);
    if (Option.isSome(option)) {
      result = option;
    }
    index = index + 1;
  }
  return Option.match({
    onNone: () => stm.succeedNone,
    onSome: core.map(Option.some)
  })(result);
}));
/** @internal */
exports.collectFirstSTM = collectFirstSTM;
const contains = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => some(self, a => Equal.equals(a)(value)));
/** @internal */
exports.contains = contains;
const count = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => reduce(self, 0, (n, a) => predicate(a) ? n + 1 : n));
/** @internal */
exports.count = count;
const countSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => reduceSTM(self, 0, (n, a) => core.map(predicate(a), bool => bool ? n + 1 : n)));
/** @internal */
exports.countSTM = countSTM;
const empty = () => fromIterable([]);
/** @internal */
exports.empty = empty;
const every = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => stm.negate(some(self, a => !predicate(a))));
/** @internal */
exports.every = every;
const everySTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(countSTM(self, predicate), count => count === self.chunk.length));
/** @internal */
exports.everySTM = everySTM;
const findFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => collectFirst(self, a => predicate(a) ? Option.some(a) : Option.none()));
/** @internal */
exports.findFirst = findFirst;
const findFirstIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => findFirstIndexFrom(self, value, 0));
/** @internal */
exports.findFirstIndex = findFirstIndex;
const findFirstIndexFrom = /*#__PURE__*/(0, _Function.dual)(3, (self, value, from) => findFirstIndexWhereFrom(self, a => Equal.equals(a)(value), from));
/** @internal */
exports.findFirstIndexFrom = findFirstIndexFrom;
const findFirstIndexWhere = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
/** @internal */
exports.findFirstIndexWhere = findFirstIndexWhere;
const findFirstIndexWhereFrom = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, from) => {
  if (from < 0) {
    return stm.succeedNone;
  }
  return core.effect(journal => {
    let index = from;
    let found = false;
    while (!found && index < self.chunk.length) {
      const element = tRef.unsafeGet(self.chunk[index], journal);
      found = predicate(element);
      index = index + 1;
    }
    if (found) {
      return Option.some(index - 1);
    }
    return Option.none();
  });
});
/** @internal */
exports.findFirstIndexWhereFrom = findFirstIndexWhereFrom;
const findFirstIndexWhereSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
/** @internal */
exports.findFirstIndexWhereSTM = findFirstIndexWhereSTM;
const findFirstIndexWhereFromSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, from) => {
  const forIndex = index => index < self.chunk.length ? core.flatMap(bool => bool ? core.succeed(Option.some(index)) : forIndex(index + 1))(core.flatMap(predicate)(tRef.get(self.chunk[index]))) : stm.succeedNone;
  return from < 0 ? stm.succeedNone : forIndex(from);
});
/** @internal */
exports.findFirstIndexWhereFromSTM = findFirstIndexWhereFromSTM;
const findFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const init = [Option.none(), 0];
  const cont = state => Option.isNone(state[0]) && state[1] < self.chunk.length - 1;
  return core.map(stm.iterate(init, {
    while: cont,
    body: state => {
      const index = state[1];
      return core.flatMap(value => core.map(predicate(value), bool => [bool ? Option.some(value) : Option.none(), index + 1]))(tRef.get(self.chunk[index]));
    }
  }), state => state[0]);
});
/** @internal */
exports.findFirstSTM = findFirstSTM;
const findLast = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.effect(journal => {
  let index = self.chunk.length - 1;
  let result = Option.none();
  while (Option.isNone(result) && index >= 0) {
    const element = tRef.unsafeGet(self.chunk[index], journal);
    if (predicate(element)) {
      result = Option.some(element);
    }
    index = index - 1;
  }
  return result;
}));
/** @internal */
exports.findLast = findLast;
const findLastIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => findLastIndexFrom(self, value, self.chunk.length - 1));
/** @internal */
exports.findLastIndex = findLastIndex;
const findLastIndexFrom = /*#__PURE__*/(0, _Function.dual)(3, (self, value, end) => {
  if (end >= self.chunk.length) {
    return stm.succeedNone;
  }
  return core.effect(journal => {
    let index = end;
    let found = false;
    while (!found && index >= 0) {
      const element = tRef.unsafeGet(self.chunk[index], journal);
      found = Equal.equals(element)(value);
      index = index - 1;
    }
    if (found) {
      return Option.some(index + 1);
    }
    return Option.none();
  });
});
/** @internal */
exports.findLastIndexFrom = findLastIndexFrom;
const findLastSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const init = [Option.none(), self.chunk.length - 1];
  const cont = state => Option.isNone(state[0]) && state[1] >= 0;
  return core.map(stm.iterate(init, {
    while: cont,
    body: state => {
      const index = state[1];
      return core.flatMap(value => core.map(predicate(value), bool => [bool ? Option.some(value) : Option.none(), index - 1]))(tRef.get(self.chunk[index]));
    }
  }), state => state[0]);
});
/** @internal */
exports.findLastSTM = findLastSTM;
const forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, void 0, (_, a) => f(a)));
/** @internal */
exports.forEach = forEach;
const fromIterable = iterable => core.map(stm.forEach(iterable, tRef.make), chunk => new TArrayImpl(chunk));
/** @internal */
exports.fromIterable = fromIterable;
const get = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => {
  if (index < 0 || index >= self.chunk.length) {
    return core.dieMessage("Index out of bounds");
  }
  return tRef.get(self.chunk[index]);
});
/** @internal */
exports.get = get;
const headOption = self => self.chunk.length === 0 ? core.succeed(Option.none()) : core.map(tRef.get(self.chunk[0]), Option.some);
/** @internal */
exports.headOption = headOption;
const lastOption = self => self.chunk.length === 0 ? stm.succeedNone : core.map(tRef.get(self.chunk[self.chunk.length - 1]), Option.some);
/** @internal */
exports.lastOption = lastOption;
const make = (...elements) => fromIterable(elements);
/** @internal */
exports.make = make;
const maxOption = /*#__PURE__*/(0, _Function.dual)(2, (self, order) => {
  const greaterThan = Order.greaterThan(order);
  return reduceOption(self, (acc, curr) => greaterThan(acc)(curr) ? curr : acc);
});
/** @internal */
exports.maxOption = maxOption;
const minOption = /*#__PURE__*/(0, _Function.dual)(2, (self, order) => {
  const lessThan = Order.lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan(acc)(curr) ? curr : acc);
});
/** @internal */
exports.minOption = minOption;
const reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => core.effect(journal => {
  let index = 0;
  let result = zero;
  while (index < self.chunk.length) {
    const element = tRef.unsafeGet(self.chunk[index], journal);
    result = f(result, element);
    index = index + 1;
  }
  return result;
}));
/** @internal */
exports.reduce = reduce;
const reduceOption = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.effect(journal => {
  let index = 0;
  let result = undefined;
  while (index < self.chunk.length) {
    const element = tRef.unsafeGet(self.chunk[index], journal);
    result = result === undefined ? element : f(result, element);
    index = index + 1;
  }
  return Option.fromNullable(result);
}));
/** @internal */
exports.reduceOption = reduceOption;
const reduceOptionSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, Option.none(), (acc, curr) => Option.isSome(acc) ? core.map(f(acc.value, curr), Option.some) : stm.succeedSome(curr)));
/** @internal */
exports.reduceOptionSTM = reduceOptionSTM;
const reduceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => core.flatMap(toArray(self), stm.reduce(zero, f)));
/** @internal */
exports.reduceSTM = reduceSTM;
const size = self => self.chunk.length;
/** @internal */
exports.size = size;
const some = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(findFirst(self, predicate), Option.isSome));
/** @internal */
exports.some = some;
const someSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(countSTM(self, predicate), n => n > 0));
/** @internal */
exports.someSTM = someSTM;
const toArray = self => stm.forEach(self.chunk, tRef.get);
/** @internal */
exports.toArray = toArray;
const transform = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.effect(journal => {
  let index = 0;
  while (index < self.chunk.length) {
    const ref = self.chunk[index];
    tRef.unsafeSet(ref, f(tRef.unsafeGet(ref, journal)), journal);
    index = index + 1;
  }
  return void 0;
}));
/** @internal */
exports.transform = transform;
const transformSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.flatMap(stm.forEach(self.chunk, ref => core.flatMap(tRef.get(ref), f)), chunk => core.effect(journal => {
  const iterator = chunk[Symbol.iterator]();
  let index = 0;
  let next;
  while ((next = iterator.next()) && !next.done) {
    tRef.unsafeSet(self.chunk[index], next.value, journal);
    index = index + 1;
  }
  return void 0;
})));
/** @internal */
exports.transformSTM = transformSTM;
const update = /*#__PURE__*/(0, _Function.dual)(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return core.dieMessage("Index out of bounds");
  }
  return tRef.update(self.chunk[index], f);
});
/** @internal */
exports.update = update;
const updateSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return core.dieMessage("Index out of bounds");
  }
  return core.flatMap(updated => tRef.set(self.chunk[index], updated))(core.flatMap(f)(tRef.get(self.chunk[index])));
});
exports.updateSTM = updateSTM;
//# sourceMappingURL=tArray.js.map