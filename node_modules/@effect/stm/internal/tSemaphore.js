"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withPermitsScoped = exports.withPermits = exports.withPermitScoped = exports.withPermit = exports.unsafeMakeSemaphore = exports.releaseN = exports.release = exports.make = exports.available = exports.acquireN = exports.acquire = exports.TSemaphoreTypeId = void 0;
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/core"));
var tRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tRef"));
var STM = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/STM"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const TSemaphoreSymbolKey = "@effect/stm/TSemaphore";
/** @internal */
const TSemaphoreTypeId = /*#__PURE__*/Symbol.for(TSemaphoreSymbolKey);
/** @internal */
exports.TSemaphoreTypeId = TSemaphoreTypeId;
class TSemaphoreImpl {
  constructor(permits) {
    this.permits = permits;
    this[_a] = TSemaphoreTypeId;
  }
}
_a = TSemaphoreTypeId;
/** @internal */
const make = permits => STM.map(tRef.make(permits), permits => new TSemaphoreImpl(permits));
/** @internal */
exports.make = make;
const acquire = self => acquireN(self, 1);
/** @internal */
exports.acquire = acquire;
const acquireN = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => core.withSTMRuntime(driver => {
  if (n < 0) {
    throw Cause.IllegalArgumentException(`Unexpected negative value ${n} passed to Semaphore.acquireN`);
  }
  const value = tRef.unsafeGet(self.permits, driver.journal);
  if (value < n) {
    return STM.retry;
  } else {
    return STM.succeed(tRef.unsafeSet(self.permits, value - n, driver.journal));
  }
}));
/** @internal */
exports.acquireN = acquireN;
const available = self => tRef.get(self.permits);
/** @internal */
exports.available = available;
const release = self => releaseN(self, 1);
/** @internal */
exports.release = release;
const releaseN = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => core.withSTMRuntime(driver => {
  if (n < 0) {
    throw Cause.IllegalArgumentException(`Unexpected negative value ${n} passed to Semaphore.releaseN`);
  }
  const current = tRef.unsafeGet(self.permits, driver.journal);
  return STM.succeed(tRef.unsafeSet(self.permits, current + n, driver.journal));
}));
/** @internal */
exports.releaseN = releaseN;
const withPermit = /*#__PURE__*/(0, _Function.dual)(2, (self, semaphore) => withPermits(self, semaphore, 1));
/** @internal */
exports.withPermit = withPermit;
const withPermits = /*#__PURE__*/(0, _Function.dual)(3, (self, semaphore, permits) => Effect.uninterruptibleMask(restore => Effect.zipRight(restore(core.commit(acquireN(permits)(semaphore))), Effect.ensuring(self, core.commit(releaseN(permits)(semaphore))))));
/** @internal */
exports.withPermits = withPermits;
const withPermitScoped = self => withPermitsScoped(self, 1);
/** @internal */
exports.withPermitScoped = withPermitScoped;
const withPermitsScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, permits) => Effect.acquireReleaseInterruptible(core.commit(acquireN(self, permits)), () => core.commit(releaseN(self, permits))));
/** @internal */
exports.withPermitsScoped = withPermitsScoped;
const unsafeMakeSemaphore = permits => {
  return new TSemaphoreImpl(new tRef.TRefImpl(permits));
};
exports.unsafeMakeSemaphore = unsafeMakeSemaphore;
//# sourceMappingURL=tSemaphore.js.map