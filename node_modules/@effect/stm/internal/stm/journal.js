"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareResetJournal = exports.isValid = exports.isInvalid = exports.execTodos = exports.commitJournal = exports.collectTodos = exports.analyzeJournal = exports.addTodo = exports.JournalAnalysisReadWrite = exports.JournalAnalysisReadOnly = exports.JournalAnalysisInvalid = void 0;
var Entry = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/stm/entry"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const JournalAnalysisInvalid = "Invalid";
/** @internal */
exports.JournalAnalysisInvalid = JournalAnalysisInvalid;
const JournalAnalysisReadWrite = "ReadWrite";
/** @internal */
exports.JournalAnalysisReadWrite = JournalAnalysisReadWrite;
const JournalAnalysisReadOnly = "ReadOnly";
/** @internal */
exports.JournalAnalysisReadOnly = JournalAnalysisReadOnly;
const commitJournal = journal => {
  for (const entry of journal) {
    Entry.commit(entry[1]);
  }
};
/**
 * Analyzes the journal, determining whether it is valid and whether it is
 * read only in a single pass. Note that information on whether the
 * journal is read only will only be accurate if the journal is valid, due
 * to short-circuiting that occurs on an invalid journal.
 *
 * @internal
 */
exports.commitJournal = commitJournal;
const analyzeJournal = journal => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = Entry.isInvalid(entry) ? JournalAnalysisInvalid : Entry.isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
/** @internal */
exports.analyzeJournal = analyzeJournal;
const prepareResetJournal = journal => {
  const saved = new Map();
  for (const entry of journal) {
    saved.set(entry[0], Entry.copy(entry[1]));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
};
/** @internal */
exports.prepareResetJournal = prepareResetJournal;
const collectTodos = journal => {
  const allTodos = new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map();
  }
  return allTodos;
};
/** @internal */
exports.collectTodos = collectTodos;
const execTodos = todos => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
/** @internal */
exports.execTodos = execTodos;
const addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};
/** @internal */
exports.addTodo = addTodo;
const isValid = journal => {
  let valid = true;
  for (const [, entry] of journal) {
    valid = Entry.isValid(entry);
    if (!valid) {
      return valid;
    }
  }
  return valid;
};
/** @internal */
exports.isValid = isValid;
const isInvalid = journal => {
  return !isValid(journal);
};
exports.isInvalid = isInvalid;
//# sourceMappingURL=journal.js.map