"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSTM = exports.update = exports.transformSTM = exports.transform = exports.toArray = exports.someSTM = exports.some = exports.size = exports.reduceSTM = exports.reduceOptionSTM = exports.reduceOption = exports.reduce = exports.minOption = exports.maxOption = exports.make = exports.lastOption = exports.headOption = exports.get = exports.fromIterable = exports.forEach = exports.findLastSTM = exports.findLastIndexFrom = exports.findLastIndex = exports.findLast = exports.findFirstSTM = exports.findFirstIndexWhereSTM = exports.findFirstIndexWhereFromSTM = exports.findFirstIndexWhereFrom = exports.findFirstIndexWhere = exports.findFirstIndexFrom = exports.findFirstIndex = exports.findFirst = exports.everySTM = exports.every = exports.empty = exports.countSTM = exports.count = exports.contains = exports.collectFirstSTM = exports.collectFirst = exports.TArrayTypeId = void 0;
var internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stm/internal/tArray"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 * @category symbols
 */
const TArrayTypeId = internal.TArrayTypeId;
/**
 * Finds the result of applying a partial function to the first value in its
 * domain.
 *
 * @since 1.0.0
 * @category elements
 */
exports.TArrayTypeId = TArrayTypeId;
const collectFirst = internal.collectFirst;
/**
 * Finds the result of applying an transactional partial function to the first
 * value in its domain.
 *
 * @since 1.0.0
 * @category elements
 */
exports.collectFirst = collectFirst;
const collectFirstSTM = internal.collectFirstSTM;
/**
 * Determine if the array contains a specified value.
 *
 * @macro trace
 * @since 1.0.0
 * @category elements
 */
exports.collectFirstSTM = collectFirstSTM;
const contains = internal.contains;
/**
 * Count the values in the array matching a predicate.
 *
 * @macro trace
 * @since 1.0.0
 * @category folding
 */
exports.contains = contains;
const count = internal.count;
/**
 * Count the values in the array matching a transactional predicate.
 *
 * @macro trace
 * @since 1.0.0
 * @category folding
 */
exports.count = count;
const countSTM = internal.countSTM;
/**
 * Makes an empty `TArray`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.countSTM = countSTM;
const empty = internal.empty;
/**
 * Atomically evaluate the conjunction of a predicate across the members of
 * the array.
 *
 * @since 1.0.0
 * @category elements
 */
exports.empty = empty;
const every = internal.every;
/**
 * Atomically evaluate the conjunction of a transactional predicate across the
 * members of the array.
 *
 * @since 1.0.0
 * @category elements
 */
exports.every = every;
const everySTM = internal.everySTM;
/**
 * Find the first element in the array matching the specified predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.everySTM = everySTM;
const findFirst = internal.findFirst;
/**
 * Get the first index of a specific value in the array.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirst = findFirst;
const findFirstIndex = internal.findFirstIndex;
/**
 * Get the first index of a specific value in the array starting from the
 * specified index.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndex = findFirstIndex;
const findFirstIndexFrom = internal.findFirstIndexFrom;
/**
 * Get the index of the first entry in the array matching a predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndexFrom = findFirstIndexFrom;
const findFirstIndexWhere = internal.findFirstIndexWhere;
/**
 * Get the index of the first entry in the array starting from the specified
 * index, matching a predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndexWhere = findFirstIndexWhere;
const findFirstIndexWhereFrom = internal.findFirstIndexWhereFrom;
/**
 * Get the index of the next entry that matches a transactional predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndexWhereFrom = findFirstIndexWhereFrom;
const findFirstIndexWhereSTM = internal.findFirstIndexWhereSTM;
/**
 * Starting at specified index, get the index of the next entry that matches a
 * transactional predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndexWhereSTM = findFirstIndexWhereSTM;
const findFirstIndexWhereFromSTM = internal.findFirstIndexWhereFromSTM;
/**
 * Find the first element in the array matching a transactional predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndexWhereFromSTM = findFirstIndexWhereFromSTM;
const findFirstSTM = internal.findFirstSTM;
/**
 * Find the last element in the array matching a predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstSTM = findFirstSTM;
const findLast = internal.findLast;
/**
 * Get the last index of a specific value in the array bounded above by a
 * specific index.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findLast = findLast;
const findLastIndex = internal.findLastIndex;
/**
 * Get the last index of a specific value in the array bounded above by a
 * specific index.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findLastIndex = findLastIndex;
const findLastIndexFrom = internal.findLastIndexFrom;
/**
 * Find the last element in the array matching a transactional predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findLastIndexFrom = findLastIndexFrom;
const findLastSTM = internal.findLastSTM;
/**
 * Atomically performs transactional effect for each item in array.
 *
 * @since 1.0.0
 * @category elements
 */
exports.findLastSTM = findLastSTM;
const forEach = internal.forEach;
/**
 * Makes a new `TArray` initialized with provided iterable.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.forEach = forEach;
const fromIterable = internal.fromIterable;
/**
 * Extracts value from ref in array.
 *
 * @since 1.0.0
 * @category elements
 */
exports.fromIterable = fromIterable;
const get = internal.get;
/**
 * The first entry of the array, if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
exports.get = get;
const headOption = internal.headOption;
/**
 * The last entry in the array, if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
exports.headOption = headOption;
const lastOption = internal.lastOption;
/**
 * Makes a new `TArray` that is initialized with specified values.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.lastOption = lastOption;
const make = internal.make;
/**
 * Atomically compute the greatest element in the array, if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
exports.make = make;
const maxOption = internal.maxOption;
/**
 * Atomically compute the least element in the array, if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
exports.maxOption = maxOption;
const minOption = internal.minOption;
/**
 * Atomically folds using a pure function.
 *
 * @since 1.0.0
 * @category folding
 */
exports.minOption = minOption;
const reduce = internal.reduce;
/**
 * Atomically reduce the array, if non-empty, by a binary operator.
 *
 * @since 1.0.0
 * @category elements
 */
exports.reduce = reduce;
const reduceOption = internal.reduceOption;
/**
 * Atomically reduce the non-empty array using a transactional binary
 * operator.
 *
 * @since 1.0.0
 * @category elements
 */
exports.reduceOption = reduceOption;
const reduceOptionSTM = internal.reduceOptionSTM;
/**
 * Atomically folds using a transactional function.
 *
 * @macro trace
 * @since 1.0.0
 * @category folding
 */
exports.reduceOptionSTM = reduceOptionSTM;
const reduceSTM = internal.reduceSTM;
/**
 * Returns the size of the `TArray`.
 *
 * @since 1.0.0
 * @category getters
 */
exports.reduceSTM = reduceSTM;
const size = internal.size;
/**
 * Determine if the array contains a value satisfying a predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.size = size;
const some = internal.some;
/**
 * Determine if the array contains a value satisfying a transactional
 * predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.some = some;
const someSTM = internal.someSTM;
/**
 * Collects all elements into a chunk.
 *
 * @since 1.0.0
 * @since 1.0.0
 * @category destructors
 */
exports.someSTM = someSTM;
const toArray = internal.toArray;
/**
 * Atomically updates all elements using a pure function.
 *
 * @since 1.0.0
 * @category elements
 */
exports.toArray = toArray;
const transform = internal.transform;
/**
 * Atomically updates all elements using a transactional effect.
 *
 * @since 1.0.0
 * @category elements
 */
exports.transform = transform;
const transformSTM = internal.transformSTM;
/**
 * Updates element in the array with given function.
 *
 * @since 1.0.0
 * @category elements
 */
exports.transformSTM = transformSTM;
const update = internal.update;
/**
 * Atomically updates element in the array with given transactional effect.
 *
 * @since 1.0.0
 * @category elements
 */
exports.update = update;
const updateSTM = internal.updateSTM;
exports.updateSTM = updateSTM;
//# sourceMappingURL=TArray.js.map