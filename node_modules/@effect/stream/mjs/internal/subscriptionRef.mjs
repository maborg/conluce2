var _a, _b, _c;
import { dual } from "@effect/data/Function";
import { pipeArguments } from "@effect/data/Pipeable";
import * as Effect from "@effect/io/Effect";
import * as Hub from "@effect/io/Hub";
import * as _circular from "@effect/io/internal/effect/circular";
import * as _ref from "@effect/io/internal/ref";
import * as Ref from "@effect/io/Ref";
import * as Synchronized from "@effect/io/Ref/Synchronized";
import * as stream from "@effect/stream/internal/stream";
/** @internal */
const SubscriptionRefSymbolKey = "@effect/stream/SubscriptionRef";
/** @internal */
export const SubscriptionRefTypeId = /*#__PURE__*/Symbol.for(SubscriptionRefSymbolKey);
/** @internal */
const subscriptionRefVariance = {
  _A: _ => _
};
/** @internal */
class SubscriptionRefImpl {
  constructor(ref, hub, semaphore) {
    this.ref = ref;
    this.hub = hub;
    this.semaphore = semaphore;
    // @ts-ignore
    this[_a] = _ref.refVariance;
    // @ts-ignore
    this[_b] = _circular.synchronizedVariance;
    this[_c] = subscriptionRefVariance;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get changes() {
    return stream.unwrapScoped(this.semaphore.withPermits(1)(Effect.flatMap(a => Effect.map(stream.fromHub(this.hub, {
      scoped: true
    }), s => stream.concat(stream.make(a), s)))(Ref.get(this.ref))));
  }
  modify(f) {
    return this.modifyEffect(a => Effect.succeed(f(a)));
  }
  modifyEffect(f) {
    return this.semaphore.withPermits(1)(Effect.flatMap(([b, a]) => Effect.zipLeft(Hub.publish(this.hub, a))(Effect.as(b)(Ref.set(this.ref, a))))(Effect.flatMap(f)(Ref.get(this.ref))));
  }
}
_a = Ref.RefTypeId, _b = Synchronized.SynchronizedTypeId, _c = SubscriptionRefTypeId;
/** @internal */
export const get = self => Ref.get(self.ref);
/** @internal */
export const make = value => Effect.map(([hub, ref, semaphore]) => new SubscriptionRefImpl(ref, hub, semaphore))(Effect.all([Hub.unbounded(), Ref.make(value), Effect.makeSemaphore(1)]));
/** @internal */
export const modify = /*#__PURE__*/dual(2, (self, f) => self.modify(f));
/** @internal */
export const modifyEffect = /*#__PURE__*/dual(2, (self, f) => self.modifyEffect(f));
/** @internal */
export const set = /*#__PURE__*/dual(2, (self, value) => self.semaphore.withPermits(1)(Effect.zipLeft(Hub.publish(self.hub, value))(Ref.set(self.ref, value))));
//# sourceMappingURL=subscriptionRef.mjs.map