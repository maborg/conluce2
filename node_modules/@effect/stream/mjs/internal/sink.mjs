var _a;
import * as Chunk from "@effect/data/Chunk";
import * as Duration from "@effect/data/Duration";
import * as Either from "@effect/data/Either";
import { constTrue, dual, identity } from "@effect/data/Function";
import * as HashMap from "@effect/data/HashMap";
import * as HashSet from "@effect/data/HashSet";
import * as Option from "@effect/data/Option";
import { pipeArguments } from "@effect/data/Pipeable";
import * as ReadonlyArray from "@effect/data/ReadonlyArray";
import * as Cause from "@effect/io/Cause";
import * as Clock from "@effect/io/Clock";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import * as Hub from "@effect/io/Hub";
import * as Queue from "@effect/io/Queue";
import * as Ref from "@effect/io/Ref";
import * as channel from "@effect/stream/internal/channel";
import * as mergeDecision from "@effect/stream/internal/channel/mergeDecision";
import * as core from "@effect/stream/internal/core";
/** @internal */
const SinkSymbolKey = "@effect/stream/Sink";
/** @internal */
export const SinkTypeId = /*#__PURE__*/Symbol.for(SinkSymbolKey);
/** @internal */
const sinkVariance = {
  _R: _ => _,
  _E: _ => _,
  _In: _ => _,
  _L: _ => _,
  _Z: _ => _
};
/** @internal */
export class SinkImpl {
  constructor(channel) {
    this.channel = channel;
    this[_a] = sinkVariance;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
_a = SinkTypeId;
/** @internal */
export const isSink = u => typeof u === "object" && u != null && SinkTypeId in u;
/** @internal */
export const suspend = evaluate => new SinkImpl(core.suspend(() => toChannel(evaluate())));
/** @internal */
export const as = /*#__PURE__*/dual(2, (self, z) => map(() => z)(self));
/** @internal */
export const collectAll = () => new SinkImpl(collectAllLoop(Chunk.empty()));
/** @internal */
const collectAllLoop = acc => core.readWithCause({
  onInput: chunk => collectAllLoop(Chunk.appendAll(chunk)(acc)),
  onFailure: core.failCause,
  onDone: () => core.succeed(acc)
});
/** @internal */
export const collectAllN = n => suspend(() => fromChannel(collectAllNLoop(n, Chunk.empty())));
/** @internal */
const collectAllNLoop = (n, acc) => core.readWithCause({
  onInput: chunk => {
    const [collected, leftovers] = Chunk.splitAt(chunk, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, Chunk.appendAll(acc, collected));
    }
    if (Chunk.isEmpty(leftovers)) {
      return core.succeed(Chunk.appendAll(acc, collected));
    }
    return core.flatMap(core.write(leftovers), () => core.succeed(Chunk.appendAll(acc, collected)));
  },
  onFailure: core.failCause,
  onDone: () => core.succeed(acc)
});
/** @internal */
export const collectAllFrom = self => collectAllWhileWith(self, {
  initial: Chunk.empty(),
  while: constTrue,
  body: (chunk, z) => Chunk.append(z)(chunk)
});
/** @internal */
export const collectAllToMap = (key, merge) => {
  return foldLeftChunks(HashMap.empty(), (map, chunk) => Chunk.reduce(map, (map, input) => {
    const k = key(input);
    const v = HashMap.has(k)(map) ? merge(HashMap.unsafeGet(k)(map), input) : input;
    return HashMap.set(k, v)(map);
  })(chunk));
};
/** @internal */
export const collectAllToMapN = (n, key, merge) => {
  return foldWeighted({
    initial: HashMap.empty(),
    maxCost: n,
    cost: (acc, input) => HashMap.has(key(input))(acc) ? 0 : 1,
    body: (acc, input) => {
      const k = key(input);
      const v = HashMap.has(k)(acc) ? merge(HashMap.unsafeGet(k)(acc), input) : input;
      return HashMap.set(k, v)(acc);
    }
  });
};
/** @internal */
export const collectAllToSet = () => foldLeftChunks(HashSet.empty(), (acc, chunk) => Chunk.reduce(acc, (acc, input) => HashSet.add(input)(acc))(chunk));
/** @internal */
export const collectAllToSetN = n => foldWeighted({
  initial: HashSet.empty(),
  maxCost: n,
  cost: (acc, input) => HashSet.has(acc, input) ? 0 : 1,
  body: (acc, input) => HashSet.add(acc, input)
});
/** @internal */
export const collectAllUntil = p => {
  return map(tuple => tuple[0])(fold([Chunk.empty(), true], tuple => tuple[1], ([chunk, _], input) => [Chunk.append(input)(chunk), !p(input)]));
};
/** @internal */
export const collectAllUntilEffect = p => {
  return map(tuple => tuple[0])(foldEffect([Chunk.empty(), true], tuple => tuple[1], ([chunk, _], input) => Effect.map(bool => [Chunk.append(input)(chunk), !bool])(p(input))));
};
/** @internal */
export const collectAllWhile = predicate => fromChannel(collectAllWhileReader(predicate, Chunk.empty()));
/** @internal */
const collectAllWhileReader = (predicate, done) => core.readWith({
  onInput: input => {
    const [collected, leftovers] = ReadonlyArray.span(predicate)(Chunk.toReadonlyArray(input));
    if (leftovers.length === 0) {
      return collectAllWhileReader(predicate, Chunk.appendAll(Chunk.unsafeFromArray(collected))(done));
    }
    return channel.zipRight(core.succeed(Chunk.appendAll(Chunk.unsafeFromArray(collected))(done)))(core.write(Chunk.unsafeFromArray(leftovers)));
  },
  onFailure: core.fail,
  onDone: () => core.succeed(done)
});
/** @internal */
export const collectAllWhileEffect = predicate => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()));
/** @internal */
const collectAllWhileEffectReader = (predicate, done) => core.readWith({
  onInput: input => core.flatMap(collected => {
    const leftovers = Chunk.drop(collected.length)(input);
    if (Chunk.isEmpty(leftovers)) {
      return collectAllWhileEffectReader(predicate, Chunk.appendAll(collected)(done));
    }
    return channel.zipRight(core.succeed(Chunk.appendAll(collected)(done)))(core.write(leftovers));
  })(core.fromEffect(Effect.map(Chunk.unsafeFromArray)(Effect.takeWhile(predicate)(input)))),
  onFailure: core.fail,
  onDone: () => core.succeed(done)
});
/** @internal */
export const collectAllWhileWith = /*#__PURE__*/dual(2, (self, options) => {
  const refs = Effect.zip(Ref.make(false))(Ref.make(Chunk.empty()));
  const newChannel = core.flatMap(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = core.readWith({
      onInput: input => core.flatMap(() => upstreamMarker)(core.write(input)),
      onFailure: core.fail,
      onDone: done => channel.as(done)(core.fromEffect(Ref.set(upstreamDoneRef, true)))
    });
    return core.pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body))(core.pipeTo(channel.bufferChunk(leftoversRef))(upstreamMarker));
  })(core.fromEffect(refs));
  return new SinkImpl(newChannel);
});
/** @internal */
const collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f) => {
  return channel.foldChannel({
    onFailure: core.fail,
    onSuccess: ([leftovers, doneValue]) => p(doneValue) ? core.flatMap(() => core.flatMap(upstreamDone => {
      const accumulatedResult = f(currentResult, doneValue);
      return upstreamDone ? channel.as(accumulatedResult)(core.write(Chunk.flatten(leftovers))) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f);
    })(core.fromEffect(Ref.get(upstreamDoneRef))))(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers)))) : channel.as(currentResult)(core.write(Chunk.flatten(leftovers)))
  })(channel.doneCollect(toChannel(self)));
};
/** @internal */
export const collectLeftover = self => new SinkImpl(channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])(core.collectElements(toChannel(self))));
/** @internal */
export const contramap = /*#__PURE__*/dual(2, (self, f) => contramapChunks(Chunk.map(f))(self));
/** @internal */
export const contramapEffect = /*#__PURE__*/dual(2, (self, f) => contramapChunksEffect(self, chunk => Effect.map(Effect.forEach(chunk, f), Chunk.unsafeFromArray)));
/** @internal */
export const contramapChunks = /*#__PURE__*/dual(2, (self, f) => {
  const loop = core.readWith({
    onInput: chunk => core.flatMap(() => loop)(core.write(f(chunk))),
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new SinkImpl(core.pipeTo(toChannel(self))(loop));
});
/** @internal */
export const contramapChunksEffect = /*#__PURE__*/dual(2, (self, f) => {
  const loop = core.readWith({
    onInput: chunk => core.flatMap(() => loop)(core.flatMap(core.write)(core.fromEffect(f(chunk)))),
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new SinkImpl(channel.pipeToOrFail(toChannel(self))(loop));
});
/** @internal */
export const die = defect => failCause(Cause.die(defect));
/** @internal */
export const dieMessage = message => failCause(Cause.die(Cause.RuntimeException(message)));
/** @internal */
export const dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));
/** @internal */
export const dimap = /*#__PURE__*/dual(2, (self, options) => map(contramap(self, options.onInput), options.onDone));
/** @internal */
export const dimapEffect = /*#__PURE__*/dual(2, (self, options) => mapEffect(contramapEffect(self, options.onInput), options.onDone));
/** @internal */
export const dimapChunks = /*#__PURE__*/dual(2, (self, options) => map(contramapChunks(self, options.onInput), options.onDone));
/** @internal */
export const dimapChunksEffect = /*#__PURE__*/dual(2, (self, options) => mapEffect(contramapChunksEffect(self, options.onInput), options.onDone));
/** @internal */
export const drain = /*#__PURE__*/new SinkImpl( /*#__PURE__*/channel.drain( /*#__PURE__*/channel.identityChannel()));
/** @internal */
export const drop = n => suspend(() => new SinkImpl(dropLoop(n)));
/** @internal */
const dropLoop = n => core.readWith({
  onInput: input => {
    const dropped = Chunk.drop(n)(input);
    const leftover = Math.max(n - input.length, 0);
    const more = Chunk.isEmpty(input) || leftover > 0;
    if (more) {
      return dropLoop(leftover);
    }
    return channel.zipRight(channel.identityChannel())(core.write(dropped));
  },
  onFailure: core.fail,
  onDone: () => core.unit
});
/** @internal */
export const dropUntil = predicate => new SinkImpl(channel.pipeToOrFail(toChannel(drop(1)))(toChannel(dropWhile(input => !predicate(input)))));
/** @internal */
export const dropUntilEffect = predicate => suspend(() => new SinkImpl(dropUntilEffectReader(predicate)));
/** @internal */
const dropUntilEffectReader = predicate => core.readWith({
  onInput: input => channel.unwrap(Effect.map(leftover => {
    const more = leftover.length === 0;
    return more ? dropUntilEffectReader(predicate) : channel.zipRight(channel.identityChannel())(core.write(Chunk.unsafeFromArray(leftover)));
  })(Effect.dropUntil(predicate)(input))),
  onFailure: core.fail,
  onDone: () => core.unit
});
/** @internal */
export const dropWhile = predicate => new SinkImpl(dropWhileReader(predicate));
/** @internal */
const dropWhileReader = predicate => core.readWith({
  onInput: input => {
    const out = Chunk.dropWhile(predicate)(input);
    if (Chunk.isEmpty(out)) {
      return dropWhileReader(predicate);
    }
    return channel.zipRight(channel.identityChannel())(core.write(out));
  },
  onFailure: core.fail,
  onDone: core.succeedNow
});
/** @internal */
export const dropWhileEffect = predicate => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)));
/** @internal */
const dropWhileEffectReader = predicate => core.readWith({
  onInput: input => channel.unwrap(Effect.map(leftover => {
    const more = leftover.length === 0;
    return more ? dropWhileEffectReader(predicate) : channel.zipRight(channel.identityChannel())(core.write(Chunk.unsafeFromArray(leftover)));
  })(Effect.dropWhile(predicate)(input))),
  onFailure: core.fail,
  onDone: () => core.unit
});
/** @internal */
export const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => new SinkImpl(channel.ensuring(finalizer)(toChannel(self))));
/** @internal */
export const ensuringWith = /*#__PURE__*/dual(2, (self, finalizer) => new SinkImpl(core.ensuringWith(finalizer)(toChannel(self))));
/** @internal */
export const context = () => fromEffect(Effect.context());
/** @internal */
export const contextWith = f => map(f)(context());
/** @internal */
export const contextWithEffect = f => mapEffect(f)(context());
/** @internal */
export const contextWithSink = f => new SinkImpl(channel.unwrap(Effect.contextWith(context => toChannel(f(context)))));
/** @internal */
export const every = predicate => fold(true, identity, (acc, input) => acc && predicate(input));
/** @internal */
export const fail = e => new SinkImpl(core.fail(e));
/** @internal */
export const failSync = evaluate => new SinkImpl(core.failSync(evaluate));
/** @internal */
export const failCause = cause => new SinkImpl(core.failCause(cause));
/** @internal */
export const failCauseSync = evaluate => new SinkImpl(core.failCauseSync(evaluate));
/** @internal */
export const filterInput = f => {
  return self => contramapChunks(Chunk.filter(f))(self);
};
/** @internal */
export const filterInputEffect = /*#__PURE__*/dual(2, (self, f) => contramapChunksEffect(self, chunk => Effect.map(Effect.filter(chunk, f), Chunk.unsafeFromArray)));
/** @internal */
export const findEffect = /*#__PURE__*/dual(2, (self, f) => {
  const newChannel = core.flatMap(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = core.readWith({
      onInput: input => core.flatMap(() => upstreamMarker)(core.write(input)),
      onFailure: core.fail,
      onDone: done => channel.as(done)(core.fromEffect(Ref.set(upstreamDoneRef, true)))
    });
    const loop = channel.foldChannel(core.collectElements(toChannel(self)), {
      onFailure: core.fail,
      onSuccess: ([leftovers, doneValue]) => core.flatMap(satisfied => channel.zipRight(core.flatMap(upstreamDone => {
        if (satisfied) {
          return channel.as(Option.some(doneValue))(core.write(Chunk.flatten(leftovers)));
        }
        if (upstreamDone) {
          return channel.as(Option.none())(core.write(Chunk.flatten(leftovers)));
        }
        return loop;
      })(core.fromEffect(Ref.get(upstreamDoneRef))))(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers)))))(core.fromEffect(f(doneValue)))
    });
    return core.pipeTo(loop)(core.pipeTo(channel.bufferChunk(leftoversRef))(upstreamMarker));
  })(core.fromEffect(Effect.zip(Ref.make(false))(Ref.make(Chunk.empty()))));
  return new SinkImpl(newChannel);
});
/** @internal */
export const fold = (s, contFn, f) => suspend(() => new SinkImpl(foldReader(s, contFn, f)));
/** @internal */
const foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith({
    onInput: input => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (Chunk.isNonEmpty(leftovers)) {
        return channel.as(nextS)(core.write(leftovers));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: core.fail,
    onDone: () => core.succeedNow(s)
  });
};
/** @internal */
const foldChunkSplit = (s, chunk, contFn, f, index, length) => {
  if (index === length) {
    return [s, Chunk.empty()];
  }
  const s1 = f(s, Chunk.unsafeGet(index)(chunk));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length);
  }
  return [s1, Chunk.drop(index + 1)(chunk)];
};
/** @internal */
export const foldSink = /*#__PURE__*/dual(2, (self, options) => {
  const newChannel = channel.foldChannel({
    onFailure: error => toChannel(options.onFailure(error)),
    onSuccess: ([leftovers, z]) => core.suspend(() => {
      const leftoversRef = {
        ref: Chunk.filter(Chunk.isNonEmpty)(leftovers)
      };
      const refReader =
      // This cast is safe because of the L1 >: L <: In1 bound. It follows that
      // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
      core.flatMap(chunk => channel.writeChunk(chunk))(core.sync(() => {
        const ref = leftoversRef.ref;
        leftoversRef.ref = Chunk.empty();
        return ref;
      }));
      const passthrough = channel.identityChannel();
      const continuationSink = core.pipeTo(toChannel(options.onSuccess(z)))(channel.zipRight(passthrough)(refReader));
      return core.flatMap(core.collectElements(continuationSink), ([newLeftovers, z1]) => channel.as(z1)(channel.zipRight(channel.writeChunk(newLeftovers))(core.flatMap(channel.writeChunk)(core.succeed(leftoversRef.ref)))));
    })
  })(core.collectElements(toChannel(self)));
  return new SinkImpl(newChannel);
});
/** @internal */
export const foldChunks = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)));
/** @internal */
const foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith({
    onInput: input => foldChunksReader(f(s, input), contFn, f),
    onFailure: core.fail,
    onDone: () => core.succeedNow(s)
  });
};
/** @internal */
export const foldChunksEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)));
/** @internal */
const foldChunksEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith({
    onInput: input => core.flatMap(s => foldChunksEffectReader(s, contFn, f))(core.fromEffect(f(s, input))),
    onFailure: core.fail,
    onDone: () => core.succeedNow(s)
  });
};
/** @internal */
export const foldEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)));
/** @internal */
const foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith({
    onInput: input => core.flatMap(([nextS, leftovers]) => Option.match({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: leftover => channel.as(nextS)(core.write(leftover))
    })(leftovers))(core.fromEffect(foldChunkSplitEffect(s, input, contFn, f))),
    onFailure: core.fail,
    onDone: () => core.succeedNow(s)
  });
};
/** @internal */
const foldChunkSplitEffect = (s, chunk, contFn, f) => foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f);
/** @internal */
const foldChunkSplitEffectInternal = (s, chunk, index, length, contFn, f) => {
  if (index === length) {
    return Effect.succeed([s, Option.none()]);
  }
  return Effect.flatMap(s1 => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) : Effect.succeed([s1, Option.some(Chunk.drop(index + 1)(chunk))]))(f(s, Chunk.unsafeGet(index)(chunk)));
};
/** @internal */
export const foldLeft = (s, f) => ignoreLeftover(fold(s, constTrue, f));
/** @internal */
export const foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
/** @internal */
export const foldLeftChunksEffect = (s, f) => ignoreLeftover(foldChunksEffect(s, constTrue, f));
/** @internal */
export const foldLeftEffect = (s, f) => foldEffect(s, constTrue, f);
/** @internal */
export const foldUntil = (s, max, f) => map(tuple => tuple[0])(fold([s, 0], tuple => tuple[1] < max, ([output, count], input) => [f(output, input), count + 1]));
/** @internal */
export const foldUntilEffect = (s, max, f) => map(tuple => tuple[0])(foldEffect([s, 0], tuple => tuple[1] < max, ([output, count], input) => Effect.map(s => [s, count + 1])(f(output, input))));
/** @internal */
export const foldWeighted = options => foldWeightedDecompose({
  ...options,
  decompose: Chunk.of
});
/** @internal */
export const foldWeightedDecompose = options => suspend(() => new SinkImpl(foldWeightedDecomposeLoop(options.initial, 0, false, options.maxCost, options.cost, options.decompose, options.body)));
/** @internal */
const foldWeightedDecomposeLoop = (s, cost, dirty, max, costFn, decompose, f) => core.readWith({
  onInput: input => {
    const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(input, 0, s, cost, dirty, max, costFn, decompose, f);
    if (Chunk.isNonEmpty(leftovers)) {
      return channel.zipRight(core.succeedNow(nextS))(core.write(leftovers));
    }
    if (cost > max) {
      return core.succeedNow(nextS);
    }
    return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max, costFn, decompose, f);
  },
  onFailure: core.fail,
  onDone: () => core.succeedNow(s)
});
/** @internal */
const foldWeightedDecomposeFold = (input, index, s, cost, dirty, max, costFn, decompose, f) => {
  if (index === input.length) {
    return [s, cost, dirty, Chunk.empty()];
  }
  const elem = Chunk.unsafeGet(index)(input);
  const total = cost + costFn(s, elem);
  if (total <= max) {
    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max, costFn, decompose, f);
  }
  const decomposed = decompose(elem);
  if (decomposed.length <= 1 && !dirty) {
    // If `elem` cannot be decomposed, we need to cross the `max` threshold. To
    // minimize "injury", we only allow this when we haven't added anything else
    // to the aggregate (dirty = false).
    return [f(s, elem), total, true, Chunk.drop(index + 1)(input)];
  }
  if (decomposed.length <= 1 && dirty) {
    // If the state is dirty and `elem` cannot be decomposed, we stop folding
    // and include `elem` in the leftovers.
    return [s, cost, dirty, Chunk.drop(index)(input)];
  }
  // `elem` got decomposed, so we will recurse with the decomposed elements pushed
  // into the chunk we're processing and see if we can aggregate further.
  const next = Chunk.appendAll(Chunk.drop(index + 1)(input))(decomposed);
  return foldWeightedDecomposeFold(next, 0, s, cost, dirty, max, costFn, decompose, f);
};
/** @internal */
export const foldWeightedDecomposeEffect = options => suspend(() => new SinkImpl(foldWeightedDecomposeEffectLoop(options.initial, options.maxCost, options.cost, options.decompose, options.body, 0, false)));
/** @internal */
export const foldWeightedEffect = options => foldWeightedDecomposeEffect({
  ...options,
  decompose: input => Effect.succeed(Chunk.of(input))
});
/** @internal */
const foldWeightedDecomposeEffectLoop = (s, max, costFn, decompose, f, cost, dirty) => core.readWith({
  onInput: input => core.flatMap(([nextS, nextCost, nextDirty, leftovers]) => {
    if (Chunk.isNonEmpty(leftovers)) {
      return channel.zipRight(core.succeedNow(nextS))(core.write(leftovers));
    }
    if (cost > max) {
      return core.succeedNow(nextS);
    }
    return foldWeightedDecomposeEffectLoop(nextS, max, costFn, decompose, f, nextCost, nextDirty);
  })(core.fromEffect(foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, dirty, cost, 0))),
  onFailure: core.fail,
  onDone: () => core.succeedNow(s)
});
/** @internal */
const foldWeightedDecomposeEffectFold = (s, max, costFn, decompose, f, input, dirty, cost, index) => {
  if (index === input.length) {
    return Effect.succeed([s, cost, dirty, Chunk.empty()]);
  }
  const elem = Chunk.unsafeGet(index)(input);
  return Effect.flatMap(total => {
    if (total <= max) {
      return Effect.flatMap(s => foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1))(f(s, elem));
    }
    return Effect.flatMap(decomposed => {
      if (decomposed.length <= 1 && !dirty) {
        // If `elem` cannot be decomposed, we need to cross the `max` threshold. To
        // minimize "injury", we only allow this when we haven't added anything else
        // to the aggregate (dirty = false).
        return Effect.map(s => [s, total, true, Chunk.drop(index + 1)(input)])(f(s, elem));
      }
      if (decomposed.length <= 1 && dirty) {
        // If the state is dirty and `elem` cannot be decomposed, we stop folding
        // and include `elem` in th leftovers.
        return Effect.succeed([s, cost, dirty, Chunk.drop(index)(input)]);
      }
      // `elem` got decomposed, so we will recurse with the decomposed elements pushed
      // into the chunk we're processing and see if we can aggregate further.
      const next = Chunk.appendAll(Chunk.drop(index + 1)(input))(decomposed);
      return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0);
    })(decompose(elem));
  })(Effect.map(newCost => cost + newCost)(costFn(s, elem)));
};
/** @internal */
export const flatMap = /*#__PURE__*/dual(2, (self, f) => foldSink(self, {
  onFailure: fail,
  onSuccess: f
}));
/** @internal */
export const forEach = f => {
  const process = core.readWithCause({
    onInput: input => core.flatMap(() => process)(core.fromEffect(Effect.forEach(input, f, {
      discard: true
    }))),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return new SinkImpl(process);
};
/** @internal */
export const forEachChunk = f => {
  const process = core.readWithCause({
    onInput: input => core.flatMap(() => process)(core.fromEffect(f(input))),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return new SinkImpl(process);
};
/** @internal */
export const forEachWhile = f => {
  const process = core.readWithCause({
    onInput: input => forEachWhileReader(f, input, 0, input.length, process),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return new SinkImpl(process);
};
/** @internal */
const forEachWhileReader = (f, input, index, length, cont) => {
  if (index === length) {
    return cont;
  }
  return channel.catchAll(error => channel.zipRight(core.fail(error))(core.write(Chunk.drop(index)(input))))(core.flatMap(bool => bool ? forEachWhileReader(f, input, index + 1, length, cont) : core.write(Chunk.drop(index)(input)))(core.fromEffect(f(Chunk.unsafeGet(index)(input)))));
};
/** @internal */
export const forEachChunkWhile = f => {
  const reader = core.readWith({
    onInput: input => core.flatMap(cont => cont ? reader : core.unit)(core.fromEffect(f(input))),
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new SinkImpl(reader);
};
/** @internal */
export const fromChannel = channel => new SinkImpl(channel);
/** @internal */
export const fromEffect = effect => new SinkImpl(core.fromEffect(effect));
/** @internal */
export const fromHub = (hub, options) => fromQueue(hub, options);
/** @internal */
export const fromPush = push => new SinkImpl(channel.unwrapScoped(Effect.map(fromPushPull)(push)));
const fromPushPull = push => core.readWith({
  onInput: input => channel.foldChannel(core.fromEffect(push(Option.some(input))), {
    onFailure: ([either, leftovers]) => Either.match(either, {
      onLeft: error => channel.zipRight(core.fail(error))(core.write(leftovers)),
      onRight: z => channel.zipRight(core.succeedNow(z))(core.write(leftovers))
    }),
    onSuccess: () => fromPushPull(push)
  }),
  onFailure: core.fail,
  onDone: () => channel.foldChannel(core.fromEffect(push(Option.none())), {
    onFailure: ([either, leftovers]) => Either.match(either, {
      onLeft: error => channel.zipRight(core.fail(error))(core.write(leftovers)),
      onRight: z => channel.zipRight(core.succeedNow(z))(core.write(leftovers))
    }),
    onSuccess: () => core.fromEffect(Effect.dieMessage("BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/stream/issues"))
  })
});
/** @internal */
export const fromQueue = (queue, options) => options?.shutdown ? unwrapScoped(Effect.map(Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown), fromQueue)) : forEachChunk(input => Queue.offerAll(queue, input));
/** @internal */
export const head = () => fold(Option.none(), Option.isNone, (option, input) => Option.match(option, {
  onNone: () => Option.some(input),
  onSome: () => option
}));
/** @internal */
export const ignoreLeftover = self => new SinkImpl(channel.drain(toChannel(self)));
/** @internal */
export const last = () => foldLeftChunks(Option.none(), (s, input) => Option.orElse(Chunk.last(input), () => s));
/** @internal */
export const leftover = chunk => new SinkImpl(core.suspend(() => core.write(chunk)));
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => {
  return new SinkImpl(channel.map(f)(toChannel(self)));
});
/** @internal */
export const mapEffect = /*#__PURE__*/dual(2, (self, f) => new SinkImpl(channel.mapEffect(f)(toChannel(self))));
/** @internal */
export const mapError = /*#__PURE__*/dual(2, (self, f) => new SinkImpl(channel.mapError(f)(toChannel(self))));
/** @internal */
export const mapLeftover = /*#__PURE__*/dual(2, (self, f) => new SinkImpl(channel.mapOut(Chunk.map(f))(toChannel(self))));
/** @internal */
export const never = /*#__PURE__*/fromEffect(Effect.never);
/** @internal */
export const orElse = /*#__PURE__*/dual(2, (self, that) => new SinkImpl(channel.orElse(() => toChannel(that()))(toChannel(self))));
/** @internal */
export const provideContext = /*#__PURE__*/dual(2, (self, context) => new SinkImpl(core.provideContext(context)(toChannel(self))));
/** @internal */
export const race = /*#__PURE__*/dual(2, (self, that) => map(Either.merge)(raceBoth(that)(self)));
/** @internal */
export const raceBoth = /*#__PURE__*/dual(args => isSink(args[1]), (self, that, options) => raceWith(self, {
  other: that,
  onSelfDone: selfDone => mergeDecision.Done(Effect.map(selfDone, Either.left)),
  onOtherDone: thatDone => mergeDecision.Done(Effect.map(thatDone, Either.right)),
  capacity: options?.capacity ?? 16
}));
/** @internal */
export const raceWith = /*#__PURE__*/dual(2, (self, options) => {
  const scoped = Effect.gen(function* ($) {
    const hub = yield* $(Hub.bounded(options?.capacity ?? 16));
    const channel1 = yield* $(channel.fromHubScoped(hub));
    const channel2 = yield* $(channel.fromHubScoped(hub));
    const reader = channel.toHub(hub);
    const writer = channel.mergeWith({
      other: core.pipeTo(toChannel(options.other))(channel2),
      onSelfDone: options.onSelfDone,
      onOtherDone: options.onOtherDone
    })(core.pipeTo(toChannel(self))(channel1));
    const racedChannel = channel.mergeWith(reader, {
      other: writer,
      onSelfDone: _ => mergeDecision.Await(exit => Effect.suspend(() => exit)),
      onOtherDone: done => mergeDecision.Done(Effect.suspend(() => done))
    });
    return new SinkImpl(racedChannel);
  });
  return unwrapScoped(scoped);
});
/** @internal */
export const refineOrDie = /*#__PURE__*/dual(2, (self, pf) => refineOrDieWith(pf, identity)(self));
/** @internal */
export const refineOrDieWith = /*#__PURE__*/dual(3, (self, pf, f) => {
  const newChannel = channel.catchAll(error => Option.match(pf(error), {
    onNone: () => core.failCauseSync(() => Cause.die(f(error))),
    onSome: core.fail
  }))(toChannel(self));
  return new SinkImpl(newChannel);
});
/** @internal */
export const service = tag => serviceWith(tag, identity);
/** @internal */
export const serviceWith = (tag, f) => fromEffect(Effect.map(tag, f));
/** @internal */
export const serviceWithEffect = (tag, f) => fromEffect(Effect.flatMap(tag, f));
/** @internal */
export const serviceWithSink = (tag, f) => new SinkImpl(channel.unwrap(Effect.map(tag, service => toChannel(f(service)))));
/** @internal */
export const some = predicate => fold(false, bool => !bool, (acc, input) => acc || predicate(input));
/** @internal */
export const splitWhere = /*#__PURE__*/dual(2, (self, f) => {
  const newChannel = core.flatMap(ref => core.flatMap(([leftovers, z]) => core.flatMap(leftover => channel.zipRight(core.succeed(z))(core.write(Chunk.appendAll(Chunk.flatten(leftovers))(leftover))))(core.fromEffect(Ref.get(ref))))(core.collectElements(channel.pipeToOrFail(toChannel(self))(splitWhereSplitter(false, ref, f)))))(core.fromEffect(Ref.make(Chunk.empty())));
  return new SinkImpl(newChannel);
});
/** @internal */
const splitWhereSplitter = (written, leftovers, f) => core.readWithCause({
  onInput: input => {
    if (Chunk.isEmpty(input)) {
      return splitWhereSplitter(written, leftovers, f);
    }
    if (written) {
      const index = indexWhere(input, f);
      if (index === -1) {
        return channel.zipRight(core.write(input), splitWhereSplitter(true, leftovers, f));
      }
      const [left, right] = Chunk.splitAt(input, index);
      return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)));
    }
    const index = indexWhere(input, f, 1);
    if (index === -1) {
      return channel.zipRight(core.write(input), splitWhereSplitter(true, leftovers, f));
    }
    const [left, right] = Chunk.splitAt(Math.max(index, 1))(input);
    return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)));
  },
  onFailure: core.failCause,
  onDone: core.succeed
});
/** @internal */
const indexWhere = (self, predicate, from = 0) => {
  const iterator = self[Symbol.iterator]();
  let index = 0;
  let result = -1;
  let next;
  while (result < 0 && (next = iterator.next()) && !next.done) {
    const a = next.value;
    if (index >= from && predicate(a)) {
      result = index;
    }
    index = index + 1;
  }
  return result;
};
/** @internal */
export const succeed = z => new SinkImpl(core.succeed(z));
/** @internal */
export const sum = /*#__PURE__*/foldLeftChunks(0, (acc, chunk) => acc + Chunk.reduce(chunk, 0, (s, a) => s + a));
/** @internal */
export const summarized = /*#__PURE__*/dual(3, (self, summary, f) => {
  const newChannel = core.flatMap(start => core.flatMap(done => channel.map(end => [done, f(start, end)])(core.fromEffect(summary)))(toChannel(self)))(core.fromEffect(summary));
  return new SinkImpl(newChannel);
});
/** @internal */
export const sync = evaluate => new SinkImpl(core.sync(evaluate));
/** @internal */
export const take = n => flatMap(acc => {
  const [taken, leftover] = Chunk.splitAt(n)(acc);
  return new SinkImpl(channel.zipRight(core.succeedNow(taken))(core.write(leftover)));
})(foldChunks(Chunk.empty(), chunk => chunk.length < n, (acc, chunk) => Chunk.appendAll(chunk)(acc)));
/** @internal */
export const toChannel = self => Effect.isEffect(self) ? toChannel(fromEffect(self)) : self.channel;
/** @internal */
export const unwrap = effect => new SinkImpl(channel.unwrap(Effect.map(sink => toChannel(sink))(effect)));
/** @internal */
export const unwrapScoped = effect => {
  return new SinkImpl(channel.unwrapScoped(Effect.map(sink => toChannel(sink))(effect)));
};
/** @internal */
export const withDuration = self => summarized(Clock.currentTimeMillis, (start, end) => Duration.millis(end - start))(self);
/** @internal */
export const zip = /*#__PURE__*/dual(args => isSink(args[1]), (self, that, options) => zipWith(self, that, (z, z2) => [z, z2], options));
/** @internal */
export const zipLeft = /*#__PURE__*/dual(args => isSink(args[1]), (self, that, options) => zipWith(self, that, (z, _) => z, options));
/** @internal */
export const zipRight = /*#__PURE__*/dual(args => isSink(args[1]), (self, that, options) => zipWith(self, that, (_, z2) => z2, options));
/** @internal */
export const zipWith = /*#__PURE__*/dual(args => isSink(args[1]), (self, that, f, options) => options?.concurrent ? raceWith(self, {
  other: that,
  onSelfDone: Exit.match({
    onFailure: cause => mergeDecision.Done(Effect.failCause(cause)),
    onSuccess: leftZ => mergeDecision.Await(Exit.match({
      onFailure: Effect.failCause,
      onSuccess: rightZ => Effect.succeed(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: Exit.match({
    onFailure: cause => mergeDecision.Done(Effect.failCause(cause)),
    onSuccess: rightZ => mergeDecision.Await(Exit.match({
      onFailure: Effect.failCause,
      onSuccess: leftZ => Effect.succeed(f(leftZ, rightZ))
    }))
  })
}) : flatMap(self, z => map(that, z2 => f(z, z2))));
// Circular with Channel
/** @internal */
export const channelToSink = self => new SinkImpl(self);
// Constants
/** @internal */
export const count = /*#__PURE__*/foldLeftChunks(0, (acc, chunk) => acc + chunk.length);
/** @internal */
export const mkString = /*#__PURE__*/suspend(() => {
  const strings = [];
  return map(() => strings.join(""))(foldLeftChunks(void 0, (_, elems) => Chunk.map(elems, elem => {
    strings.push(String(elem));
  })));
});
/** @internal */
export const timed = /*#__PURE__*/map(tuple => tuple[1])( /*#__PURE__*/withDuration(drain));
//# sourceMappingURL=sink.mjs.map