var _a;
import * as Chunk from "@effect/data/Chunk";
import * as Context from "@effect/data/Context";
import * as Duration from "@effect/data/Duration";
import * as Either from "@effect/data/Either";
import * as Equal from "@effect/data/Equal";
import { constTrue, dual, identity } from "@effect/data/Function";
import * as Option from "@effect/data/Option";
import { pipeArguments } from "@effect/data/Pipeable";
import * as Cause from "@effect/io/Cause";
import * as Clock from "@effect/io/Clock";
import * as Deferred from "@effect/io/Deferred";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import * as Fiber from "@effect/io/Fiber";
import * as Hub from "@effect/io/Hub";
import * as Layer from "@effect/io/Layer";
import * as Queue from "@effect/io/Queue";
import * as Ref from "@effect/io/Ref";
import * as Runtime from "@effect/io/Runtime";
import * as Schedule from "@effect/io/Schedule";
import * as Scope from "@effect/io/Scope";
import * as MergeDecision from "@effect/stream/Channel/MergeDecision";
import * as channel from "@effect/stream/internal/channel";
import * as channelExecutor from "@effect/stream/internal/channel/channelExecutor";
import * as MergeStrategy from "@effect/stream/internal/channel/mergeStrategy";
import * as singleProducerAsyncInput from "@effect/stream/internal/channel/singleProducerAsyncInput";
import * as core from "@effect/stream/internal/core";
import * as _sink from "@effect/stream/internal/sink";
import * as DebounceState from "@effect/stream/internal/stream/debounceState";
import * as emit from "@effect/stream/internal/stream/emit";
import * as haltStrategy from "@effect/stream/internal/stream/haltStrategy";
import * as Handoff from "@effect/stream/internal/stream/handoff";
import * as HandoffSignal from "@effect/stream/internal/stream/handoffSignal";
import * as pull from "@effect/stream/internal/stream/pull";
import * as SinkEndReason from "@effect/stream/internal/stream/sinkEndReason";
import * as ZipAllState from "@effect/stream/internal/stream/zipAllState";
import * as ZipChunksState from "@effect/stream/internal/stream/zipChunksState";
import { RingBuffer } from "@effect/stream/internal/support";
import * as _take from "@effect/stream/internal/take";
import * as HaltStrategy from "@effect/stream/Stream/HaltStrategy";
/** @internal */
const StreamSymbolKey = "@effect/stream/Stream";
/** @internal */
export const StreamTypeId = /*#__PURE__*/Symbol.for(StreamSymbolKey);
/** @internal */
const streamVariance = {
  _R: _ => _,
  _E: _ => _,
  _A: _ => _
};
/** @internal */
export class StreamImpl {
  constructor(channel) {
    this.channel = channel;
    this[_a] = streamVariance;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
_a = StreamTypeId;
/** @internal */
export const isStream = u => typeof u === "object" && u != null && StreamTypeId in u || Effect.isEffect(u);
/** @internal */
export const DefaultChunkSize = 4096;
/** @internal */
export const acquireRelease = (acquire, release) => scoped(Effect.acquireRelease(acquire, release));
/** @internal */
export const aggregate = /*#__PURE__*/dual(2, (self, sink) => aggregateWithin(self, sink, Schedule.forever));
/** @internal */
export const aggregateWithin = /*#__PURE__*/dual(3, (self, sink, schedule) => filterMap(aggregateWithinEither(self, sink, schedule), _ => Either.match(_, {
  onLeft: Option.none,
  onRight: Option.some
})));
/** @internal */
export const aggregateWithinEither = /*#__PURE__*/dual(3, (self, sink, schedule) => {
  const layer = Effect.all([Handoff.make(), Ref.make(SinkEndReason.ScheduleEnd), Ref.make(Chunk.empty()), Schedule.driver(schedule), Ref.make(false), Ref.make(false)]);
  return flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = core.readWithCause({
      onInput: input => core.flatMap(core.fromEffect(Effect.when(() => Chunk.isNonEmpty(input))(Handoff.offer(HandoffSignal.emit(input))(handoff))), () => handoffProducer),
      onFailure: cause => core.fromEffect(Handoff.offer(handoff, HandoffSignal.halt(cause))),
      onDone: () => core.fromEffect(Handoff.offer(handoff, HandoffSignal.end(SinkEndReason.UpstreamEnd)))
    });
    const handoffConsumer = channel.unwrap(Effect.flatMap(leftovers => {
      if (Chunk.isNonEmpty(leftovers)) {
        return Effect.zipRight(Effect.succeed(core.flatMap(() => handoffConsumer)(core.write(leftovers))))(Ref.set(consumed, true));
      }
      return Effect.map(signal => {
        switch (signal._tag) {
          case HandoffSignal.OP_EMIT:
            {
              return core.flatMap(bool => bool ? core.unit : handoffConsumer)(channel.zipRight(core.fromEffect(Ref.get(endAfterEmit)))(channel.zipRight(core.write(signal.elements))(core.fromEffect(Ref.set(consumed, true)))));
            }
          case HandoffSignal.OP_HALT:
            {
              return core.failCause(signal.cause);
            }
          case HandoffSignal.OP_END:
            {
              if (signal.reason._tag === SinkEndReason.OP_SCHEDULE_END) {
                return channel.unwrap(Effect.map(bool => bool ? core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd))) : core.flatMap(() => handoffConsumer)(core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd)))))(Ref.get(consumed)));
              }
              return core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, signal.reason)));
            }
        }
      })(Handoff.take(handoff));
    })(Ref.getAndSet(sinkLeftovers, Chunk.empty())));
    const timeout = lastB => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope) => {
      const forkSink = Effect.zipRight(Effect.forkIn(scope)(channelExecutor.run(core.collectElements(channel.pipeToOrFail(_sink.toChannel(sink))(handoffConsumer)))))(Effect.zipRight(Ref.set(endAfterEmit, false))(Ref.set(consumed, false)));
      const handleSide = (leftovers, b, c) => channel.unwrap(Effect.zipRight(Effect.map(Ref.get(sinkEndReason), reason => {
        switch (reason._tag) {
          case SinkEndReason.OP_SCHEDULE_END:
            {
              return channel.unwrap(Effect.map(([wasConsumed, sinkFiber, scheduleFiber]) => {
                const toWrite = Option.match({
                  onNone: () => Chunk.of(Either.right(b)),
                  onSome: c => Chunk.make(Either.right(b), Either.left(c))
                })(c);
                if (wasConsumed) {
                  return core.flatMap(() => scheduledAggregator(sinkFiber, scheduleFiber, scope))(core.write(toWrite));
                }
                return scheduledAggregator(sinkFiber, scheduleFiber, scope);
              })(Effect.all([Ref.get(consumed), forkSink, Effect.forkIn(scope)(timeout(Option.some(b)))])));
            }
          case SinkEndReason.OP_UPSTREAM_END:
            {
              return channel.unwrap(Effect.map(wasConsumed => wasConsumed ? core.write(Chunk.of(Either.right(b))) : core.unit)(Ref.get(consumed)));
            }
        }
      }))(Ref.set(sinkLeftovers, Chunk.flatten(leftovers))));
      return channel.unwrap(Effect.raceWith(Fiber.join(sinkFiber), {
        other: Fiber.join(scheduleFiber),
        onSelfDone: (sinkExit, _) => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Effect.suspend(() => sinkExit)))(Fiber.interrupt(scheduleFiber)),
        onOtherDone: (scheduleExit, _) => Effect.matchCauseEffect(Effect.suspend(() => scheduleExit), {
          onFailure: cause => Either.match(Cause.failureOrCause(cause), {
            onLeft: () => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.end(SinkEndReason.ScheduleEnd))(handoff))),
            onRight: cause => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.halt(cause))(handoff)))
          }),
          onSuccess: c => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.some(c)))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.end(SinkEndReason.ScheduleEnd))(handoff)))
        })
      }));
    };
    return unwrapScoped(Effect.zipRight(Effect.flatMap(sinkFiber => Effect.flatMap(scheduleFiber => Effect.map(scope => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope)))(Effect.scope))(Effect.forkScoped(timeout(Option.none()))))(Effect.forkScoped(channelExecutor.run(core.collectElements(channel.pipeToOrFail(_sink.toChannel(sink))(handoffConsumer))))))(Effect.forkScoped(channelExecutor.run(core.pipeTo(handoffProducer)(toChannel(self))))));
  })(fromEffect(layer));
});
/** @internal */
export const as = /*#__PURE__*/dual(2, (self, value) => map(self, () => value));
/** @internal */
export const _async = (register, outputBuffer = 16) => asyncOption(cb => {
  register(cb);
  return Option.none();
}, outputBuffer);
/** @internal */
export const asyncEffect = (register, outputBuffer = 16) => fromChannel(channel.unwrapScoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.map(() => {
  const loop = channel.unwrap(Effect.match({
    onFailure: maybeError => channel.zipRight(Option.match(maybeError, {
      onNone: () => core.unit,
      onSome: core.fail
    }))(core.fromEffect(Queue.shutdown(output))),
    onSuccess: chunk => core.flatMap(() => loop)(core.write(chunk))
  })(Effect.flatMap(_take.done)(Queue.take(output))));
  return loop;
})(register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {
  if (Exit.isFailure(exit)) {
    if (!Cause.isInterrupted(exit.cause)) {
      throw Cause.squash(exit.cause);
    }
  }
})))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue)))));
/** @internal */
export const asyncInterrupt = (register, outputBuffer = 16) => unwrapScoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.map(Either.match({
  onLeft: canceler => {
    const loop = channel.unwrap(Effect.match({
      onFailure: maybeError => channel.zipRight(core.fromEffect(Queue.shutdown(output)), Option.match(maybeError, {
        onNone: () => core.unit,
        onSome: core.fail
      })),
      onSuccess: chunk => core.flatMap(() => loop)(core.write(chunk))
    })(Effect.flatMap(_take.done)(Queue.take(output))));
    return ensuring(canceler)(fromChannel(loop));
  },
  onRight: stream => unwrap(Effect.as(stream)(Queue.shutdown(output)))
}))(Effect.sync(() => register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {
  if (Exit.isFailure(exit)) {
    if (!Cause.isInterrupted(exit.cause)) {
      throw Cause.squash(exit.cause);
    }
  }
}))))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue))));
/** @internal */
export const asyncOption = (register, outputBuffer = 16) => asyncInterrupt(emit => Option.match(register(emit), {
  onNone: () => Either.left(Effect.unit),
  onSome: Either.right
}), outputBuffer);
/** @internal */
export const asyncScoped = (register, outputBuffer = 16) => flatMap(repeatEffectChunkOption)(scoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.flatMap(ref => Effect.map(isDone => isDone ? pull.end() : Effect.onError(() => Effect.zipRight(Queue.shutdown(output))(Ref.set(ref, true)))(Effect.flatMap(_take.done)(Queue.take(output))))(Ref.get(ref)))(Effect.zipRight(Ref.make(false))(register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {
  if (Exit.isFailure(exit)) {
    if (!Cause.isInterrupted(exit.cause)) {
      throw Cause.squash(exit.cause);
    }
  }
}))))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue)))));
/** @internal */
export const branchAfter = /*#__PURE__*/dual(3, (self, n, f) => suspend(() => {
  const bufferring = acc => core.readWith({
    onInput: input => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = Chunk.splitAt(n - acc.length)(input);
        return running(Chunk.appendAll(b1)(acc), b2);
      }
      return bufferring(Chunk.appendAll(input)(acc));
    },
    onFailure: core.fail,
    onDone: () => running(acc, Chunk.empty())
  });
  const running = (prefix, leftover) => core.pipeTo(toChannel(f(prefix)))(toChannel(prepend(leftover)));
  return new StreamImpl(channel.pipeToOrFail(bufferring(Chunk.empty()))(toChannel(self)));
}));
/** @internal */
export const broadcast = /*#__PURE__*/dual(3, (self, n, maximumLag) => Effect.map(tuple => tuple.map(queue => flattenTake(fromQueue(queue, {
  shutdown: true
}))))(broadcastedQueues(n, maximumLag)(self)));
/** @internal */
export const broadcastDynamic = /*#__PURE__*/dual(2, (self, maximumLag) => Effect.map(effect => flattenTake(flatMap(scoped(effect), fromQueue)))(broadcastedQueuesDynamic(maximumLag)(self)));
/** @internal */
export const broadcastedQueues = /*#__PURE__*/dual(3, (self, n, maximumLag) => Effect.flatMap(Hub.bounded(maximumLag), hub => Effect.tap(() => Effect.forkScoped(runIntoHubScoped(self, hub)))(Effect.all(Array.from({
  length: n
}, () => Hub.subscribe(hub))))));
/** @internal */
export const broadcastedQueuesDynamic = /*#__PURE__*/dual(2, (self, maximumLag) => Effect.map(toHub(self, maximumLag), Hub.subscribe));
/** @internal */
export const buffer = /*#__PURE__*/dual(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {
    const process = core.flatMap(Exit.match({
      onFailure: cause => Option.match({
        onNone: () => core.unit,
        onSome: core.failCause
      })(Cause.flipCauseOption(cause)),
      onSuccess: value => core.flatMap(core.write(Chunk.of(value)), () => process)
    }))(core.fromEffect(Queue.take(queue)));
    return process;
  })));
});
/** @internal */
export const bufferChunks = /*#__PURE__*/dual(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue(self, options);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {
    const process = core.flatMap(_take.match({
      onEnd: () => core.unit,
      onFailure: core.failCause,
      onSuccess: value => core.flatMap(() => process)(core.write(value))
    }))(core.fromEffect(Queue.take(queue)));
    return process;
  })));
});
const bufferChunksDropping = /*#__PURE__*/dual(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(self)));
});
const bufferChunksSliding = /*#__PURE__*/dual(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(self)));
});
const bufferDropping = /*#__PURE__*/dual(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));
});
const bufferSliding = /*#__PURE__*/dual(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));
});
const bufferUnbounded = self => {
  const queue = toQueue(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {
    const process = core.flatMap(_take.match({
      onEnd: () => core.unit,
      onFailure: core.failCause,
      onSuccess: value => core.flatMap(core.write(value), () => process)
    }))(core.fromEffect(Queue.take(queue)));
    return process;
  })));
};
/** @internal */
const bufferSignal = (scoped, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = take => core.fromEffect(Effect.asUnit(Effect.flatMap(deferred => Effect.zipRight(Deferred.await(deferred))(Effect.zipRight(Ref.set(ref, deferred))(Queue.offer(queue, [take, deferred]))))(Effect.zipRight(Deferred.make())(Effect.tap(Deferred.await)(Ref.get(ref))))));
    return core.readWithCause({
      onInput: input => core.flatMap(() => producer(queue, ref))(core.fromEffect(Effect.asUnit(Effect.flatMap(deferred => Effect.flatMap(added => Effect.when(() => added)(Ref.set(ref, deferred)))(Queue.offer(queue, [_take.chunk(input), deferred])))(Deferred.make())))),
      onFailure: error => terminate(_take.failCause(error)),
      onDone: () => terminate(_take.end)
    });
  };
  const consumer = queue => {
    const process = core.flatMap(([take, deferred]) => channel.zipRight(core.fromEffect(Deferred.succeed(deferred, void 0)), _take.match(take, {
      onEnd: () => core.unit,
      onFailure: core.failCause,
      onSuccess: value => core.flatMap(() => process)(core.write(value))
    })))(core.fromEffect(Queue.take(queue)));
    return process;
  };
  return channel.unwrapScoped(Effect.flatMap(queue => Effect.flatMap(start => Effect.as(consumer(queue))(Effect.flatMap(ref => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(queue, ref))(bufferChannel))))(Ref.make(start))))(Effect.tap(start => Deferred.succeed(start, void 0))(Deferred.make())))(scoped));
};
/** @internal */
export const catchAll = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => Either.match(Cause.failureOrCause(cause), {
  onLeft: f,
  onRight: failCause
})));
/** @internal */
export const catchAllCause = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(core.catchAllCause(cause => toChannel(f(cause)))(toChannel(self))));
/** @internal */
export const catchSome = /*#__PURE__*/dual(2, (self, pf) => catchAll(error => Option.getOrElse(() => fail(error))(pf(error)))(self));
/** @internal */
export const catchSomeCause = /*#__PURE__*/dual(2, (self, pf) => catchAllCause(cause => Option.getOrElse(() => failCause(cause))(pf(cause)))(self));
/* @internal */
export const catchTag = /*#__PURE__*/dual(3, (self, k, f) => catchAll(self, e => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail(e);
}));
/** @internal */
export const catchTags = /*#__PURE__*/dual(2, (self, cases) => catchAll(self, e => {
  const keys = Object.keys(cases);
  if ("_tag" in e && keys.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail(e);
}));
/** @internal */
export const changes = self => changesWith((x, y) => Equal.equals(y)(x))(self);
/** @internal */
export const changesWith = /*#__PURE__*/dual(2, (self, f) => {
  const writer = last => core.readWithCause({
    onInput: input => {
      const [newLast, newChunk] = Chunk.reduce(input, [last, Chunk.empty()], ([option, outputs], output) => {
        if (Option.isSome(option) && f(option.value, output)) {
          return [Option.some(output), outputs];
        }
        return [Option.some(output), Chunk.append(output)(outputs)];
      });
      return core.flatMap(core.write(newChunk), () => writer(newLast));
    },
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(writer(Option.none()))(toChannel(self)));
});
/** @internal */
export const changesWithEffect = /*#__PURE__*/dual(2, (self, f) => {
  const writer = last => core.readWithCause({
    onInput: input => core.flatMap(([newLast, newChunk]) => core.flatMap(() => writer(newLast))(core.write(newChunk)))(core.fromEffect(Effect.reduce([last, Chunk.empty()], ([option, outputs], output) => {
      if (Option.isSome(option)) {
        return Effect.map(bool => bool ? [Option.some(output), outputs] : [Option.some(output), Chunk.append(output)(outputs)])(f(option.value, output));
      }
      return Effect.succeed([Option.some(output), Chunk.append(output)(outputs)]);
    })(input))),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(writer(Option.none()))(toChannel(self)));
});
/** @internal */
export const chunks = self => mapChunks(Chunk.of)(self);
/** @internal */
export const chunksWith = /*#__PURE__*/dual(2, (self, f) => flattenChunks(f(chunks(self))));
/** @internal */
export const combine = /*#__PURE__*/dual(4, (self, that, s, f) => {
  const producer = (handoff, latch) => channel.zipRight(core.readWithCause({
    onInput: input => core.flatMap(core.fromEffect(Handoff.offer(Exit.succeed(input))(handoff)), () => producer(handoff, latch)),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, Exit.failCause(Cause.map(Option.some)(cause)))),
    onDone: () => core.flatMap(core.fromEffect(Handoff.offer(handoff, Exit.fail(Option.none()))), () => producer(handoff, latch))
  }))(core.fromEffect(Handoff.take(latch)));
  return new StreamImpl(channel.unwrapScoped(Effect.gen(function* ($) {
    const left = yield* $(Handoff.make());
    const right = yield* $(Handoff.make());
    const latchL = yield* $(Handoff.make());
    const latchR = yield* $(Handoff.make());
    yield* $(Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left, latchL))(channel.concatMap(channel.writeChunk)(toChannel(self))))));
    yield* $(Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right, latchR))(channel.concatMap(channel.writeChunk)(toChannel(that))))));
    const pullLeft =
    // TODO: remove
    Effect.zipRight(Effect.flatMap(exit => Effect.suspend(() => exit))(Handoff.take(left)))(Handoff.offer(void 0)(latchL));
    const pullRight =
    // TODO: remove
    Effect.zipRight(Effect.flatMap(exit => Effect.suspend(() => exit))(Handoff.take(right)))(Handoff.offer(void 0)(latchR));
    return toChannel(unfoldEffect(s, s =>
    // TODO: remove
    Effect.flatMap(exit => Effect.unsome(Effect.suspend(() => exit)))(f(s, pullLeft, pullRight))));
  })));
});
/** @internal */
export const combineChunks = /*#__PURE__*/dual(4, (self, that, s, f) => {
  const producer = (handoff, latch) => channel.zipRight(core.fromEffect(Handoff.take(latch)), core.readWithCause({
    onInput: input => core.flatMap(core.fromEffect(Handoff.offer(_take.chunk(input))(handoff)), () => producer(handoff, latch)),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, _take.failCause(cause))),
    onDone: () => core.fromEffect(Handoff.offer(handoff, _take.end))
  }));
  return new StreamImpl(channel.unwrapScoped(Effect.map(([left, right, latchL, latchR]) => {
    const pullLeft = Effect.zipRight(Effect.flatMap(_take.done)(Handoff.take(left)))(Handoff.offer(void 0)(latchL));
    const pullRight = Effect.zipRight(Effect.flatMap(_take.done)(Handoff.take(right)))(Handoff.offer(void 0)(latchR));
    return toChannel(unfoldChunkEffect(s, s =>
    // TODO: remove
    Effect.flatMap(exit => Effect.unsome(Effect.suspend(() => exit)))(f(s, pullLeft, pullRight))));
  })(Effect.tap(([_, right, __, latchR]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right, latchR))(toChannel(that)))))(Effect.tap(([left, _, latchL]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left, latchL))(toChannel(self)))))(Effect.all([Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()]))))));
});
/** @internal */
export const concat = /*#__PURE__*/dual(2, (self, that) => new StreamImpl(channel.zipRight(toChannel(that))(toChannel(self))));
/** @internal */
export const concatAll = streams => suspend(() => Chunk.reduce(empty, (x, y) => concat(y)(x))(streams));
/** @internal */
export const cross = /*#__PURE__*/dual(2, (self, that) => crossWith(that, (a, a2) => [a, a2])(self));
/** @internal */
export const crossLeft = /*#__PURE__*/dual(2, (self, that) => crossWith(that, (a, _) => a)(self));
/** @internal */
export const crossRight = /*#__PURE__*/dual(2, (self, that) => flatMap(self, () => that));
/** @internal */
export const crossWith = /*#__PURE__*/dual(3, (self, that, f) => flatMap(a => map(b => f(a, b))(that))(self));
/** @internal */
export const debounce = /*#__PURE__*/dual(2, (self, duration) => unwrap(Effect.flatMap(input => Effect.transplant(grafter => Effect.map(handoff => {
  const enqueue = last => Effect.map(fiber => consumer(DebounceState.previous(fiber)))(grafter(Effect.fork(Effect.as(last)(Clock.sleep(duration)))));
  const producer = core.readWithCause({
    onInput: input => Option.match(Chunk.last(input), {
      onNone: () => producer,
      onSome: last => core.flatMap(core.fromEffect(Handoff.offer(handoff, HandoffSignal.emit(Chunk.of(last)))), () => producer)
    }),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, HandoffSignal.halt(cause))),
    onDone: () => core.fromEffect(Handoff.offer(handoff, HandoffSignal.end(SinkEndReason.UpstreamEnd)))
  });
  const consumer = state => {
    switch (state._tag) {
      case DebounceState.OP_NOT_STARTED:
        {
          return channel.unwrap(Effect.map(signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return channel.unwrap(enqueue(signal.elements));
                }
              case HandoffSignal.OP_HALT:
                {
                  return core.failCause(signal.cause);
                }
              case HandoffSignal.OP_END:
                {
                  return core.unit;
                }
            }
          })(Handoff.take(handoff)));
        }
      case DebounceState.OP_PREVIOUS:
        {
          return channel.unwrap(Effect.raceWith(Fiber.join(state.fiber), {
            other: Handoff.take(handoff),
            onSelfDone: (leftExit, current) => Exit.match(leftExit, {
              onFailure: cause => Effect.as(core.failCause(cause))(Fiber.interrupt(current)),
              onSuccess: chunk => Effect.succeed(core.flatMap(() => consumer(DebounceState.current(current)))(core.write(chunk)))
            }),
            onOtherDone: (rightExit, previous) => Exit.match(rightExit, {
              onFailure: cause => Effect.as(core.failCause(cause))(Fiber.interrupt(previous)),
              onSuccess: signal => {
                switch (signal._tag) {
                  case HandoffSignal.OP_EMIT:
                    {
                      return Effect.zipRight(enqueue(signal.elements))(Fiber.interrupt(previous));
                    }
                  case HandoffSignal.OP_HALT:
                    {
                      return Effect.as(core.failCause(signal.cause))(Fiber.interrupt(previous));
                    }
                  case HandoffSignal.OP_END:
                    {
                      return Effect.map(chunk => channel.zipRight(core.unit)(core.write(chunk)))(Fiber.join(previous));
                    }
                }
              }
            })
          }));
        }
      case DebounceState.OP_CURRENT:
        {
          return channel.unwrap(Effect.map(signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return channel.unwrap(enqueue(signal.elements));
                }
              case HandoffSignal.OP_HALT:
                {
                  return core.failCause(signal.cause);
                }
              case HandoffSignal.OP_END:
                {
                  return core.unit;
                }
            }
          })(Fiber.join(state.fiber)));
        }
    }
  };
  const debounceChannel = channel.unwrapScoped(Effect.as(core.embedInput(input)(consumer(DebounceState.notStarted)))(Effect.forkScoped(channelExecutor.run(core.pipeTo(producer)(channel.fromInput(input))))));
  return new StreamImpl(core.pipeTo(debounceChannel)(toChannel(self)));
})(Handoff.make())))(singleProducerAsyncInput.make())));
/** @internal */
export const die = defect => fromEffect(Effect.die(defect));
/** @internal */
export const dieSync = evaluate => fromEffect(Effect.dieSync(evaluate));
/** @internal */
export const dieMessage = message => fromEffect(Effect.dieMessage(message));
/** @internal */
export const distributedWith = /*#__PURE__*/dual(2, (self, options) => Effect.flatMap(deferred => Effect.flatMap(next => Effect.flatMap(entries => {
  const [mappings, queues] = Chunk.reduceRight(entries, [new Map(), Chunk.empty()], ([mappings, queues], [mapping, queue]) => [mappings.set(mapping[0], mapping[1]), Chunk.prepend(queue)(queues)]);
  return Effect.as(Array.from(queues))(Deferred.succeed(deferred, a => Effect.map(options.decide(a), f => key => f(mappings.get(key)))));
})(Effect.map(Chunk.unsafeFromArray)(Effect.all(Chunk.map(Chunk.range(0, options.size - 1), id => Effect.map(next, ([key, queue]) => [[key, id], queue]))))))(distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: a => Effect.flatMap(Deferred.await(deferred), f => f(a))
})(self)))(Deferred.make()));
/** @internal */
const distributedWithDynamicId = {
  ref: 0
};
const newDistributedWithDynamicId = () => {
  const current = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current + 1;
  return current;
};
/** @internal */
export const distributedWithDynamic = /*#__PURE__*/dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => Effect.unit));
export const distributedWithDynamicCallback = /*#__PURE__*/dual(4, (self, maximumLag, decide, done) => Effect.flatMap(queuesRef => Effect.gen(function* ($) {
  const offer = a => Effect.asUnit(Effect.flatMap(shouldProcess => Effect.flatMap(queues => Effect.flatMap(ids => {
    if (Chunk.isNonEmpty(ids)) {
      return Ref.update(queuesRef, map => {
        for (const id of ids) {
          map.delete(id);
        }
        return map;
      });
    }
    return Effect.unit;
  })(Effect.reduce(Chunk.empty(), (acc, [id, queue]) => {
    if (shouldProcess(id)) {
      return Effect.matchCauseEffect({
        onFailure: cause =>
        // Ignore all downstream queues that were shut
        // down and remove them later
        Cause.isInterrupted(cause) ? Effect.succeed(Chunk.prepend(id)(acc)) : Effect.failCause(cause),
        onSuccess: () => Effect.succeed(acc)
      })(Queue.offer(queue, Exit.succeed(a)));
    }
    return Effect.succeed(acc);
  })(queues.entries())))(Ref.get(queuesRef)))(decide(a)));
  const queuesLock = yield* $(Effect.makeSemaphore(1));
  const newQueue = yield* $(Ref.make(Effect.flatMap(queue => {
    const id = newDistributedWithDynamicId();
    return Effect.as([id, queue])(Ref.update(queuesRef, map => map.set(id, queue)));
  })(Queue.bounded(maximumLag))));
  const finalize = endTake =>
  // Make sure that no queues are currently being added
  queuesLock.withPermits(1)(Effect.asUnit(Effect.zipRight(done(endTake))(Effect.zipRight(Effect.flatMap(map => Effect.forEach(queue => Effect.catchSomeCause(cause => Cause.isInterrupted(cause) ? Option.some(Effect.unit) : Option.none())(Queue.offer(queue, endTake)))(Chunk.fromIterable(map.values())))(Ref.get(queuesRef)))(Ref.set(newQueue, Effect.flatMap(queue => {
    const id = newDistributedWithDynamicId();
    return Effect.as([id, queue])(Ref.update(queuesRef, map => map.set(id, queue)));
  })(Effect.tap(queue => Queue.offer(queue, endTake))(
  // All newly created queues should end immediately
  Queue.bounded(1))))))));
  yield* $(Effect.forkScoped(Effect.matchCauseEffect({
    onFailure: cause => finalize(Exit.failCause(Cause.map(Option.some)(cause))),
    onSuccess: () => finalize(Exit.fail(Option.none()))
  })(runForEachScoped(offer)(self))));
  return queuesLock.withPermits(1)(Effect.flatten(Ref.get(newQueue)));
}))(Effect.acquireRelease(Ref.make(new Map()), (ref, _) => Effect.flatMap(queues => Effect.forEach(Queue.shutdown)(queues.values()))(Ref.get(ref)))));
/** @internal */
export const drain = self => new StreamImpl(channel.drain(toChannel(self)));
/** @internal */
export const drainFork = /*#__PURE__*/dual(2, (self, that) => flatMap(backgroundDied => crossRight(interruptWhenDeferred(backgroundDied)(self))(scoped(Effect.forkScoped(Effect.catchAllCause(cause => Deferred.failCause(backgroundDied, cause))(runForEachScoped(() => Effect.unit)(that))))))(fromEffect(Deferred.make())));
/** @internal */
export const drop = /*#__PURE__*/dual(2, (self, n) => {
  const loop = r => core.readWith({
    onInput: input => {
      const dropped = Chunk.drop(r)(input);
      const leftover = Math.max(0, r - input.length);
      const more = Chunk.isEmpty(input) || leftover > 0;
      if (more) {
        return loop(leftover);
      }
      return channel.zipRight(channel.identityChannel())(core.write(dropped));
    },
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(channel.pipeToOrFail(loop(n))(toChannel(self)));
});
/** @internal */
export const dropRight = /*#__PURE__*/dual(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend(() => {
    const queue = new RingBuffer(n);
    const reader = core.readWith({
      onInput: input => {
        const outputs = Chunk.filterMap(elem => {
          const head = queue.head();
          queue.put(elem);
          return head;
        })(input);
        return core.flatMap(() => reader)(core.write(outputs));
      },
      onFailure: core.fail,
      onDone: () => core.unit
    });
    return new StreamImpl(channel.pipeToOrFail(reader)(toChannel(self)));
  });
});
/** @internal */
export const dropUntil = /*#__PURE__*/dual(2, (self, predicate) => drop(dropWhile(self, a => !predicate(a)), 1));
/** @internal */
export const dropUntilEffect = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => channel.unwrap(Effect.map(leftover => {
      const more = Chunk.isEmpty(leftover);
      if (more) {
        return core.suspend(() => loop);
      }
      return channel.zipRight(channel.identityChannel())(core.write(leftover));
    })(Effect.map(Chunk.unsafeFromArray)(Effect.dropUntil(input, predicate)))),
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
export const dropWhile = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => {
      const output = Chunk.dropWhile(input, predicate);
      if (Chunk.isEmpty(output)) {
        return core.suspend(() => loop);
      }
      return channel.zipRight(core.write(output), channel.identityChannel());
    },
    onFailure: core.fail,
    onDone: core.succeedNow
  });
  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop));
});
/** @internal */
export const dropWhileEffect = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => channel.unwrap(Effect.map(leftover => {
      const more = Chunk.isEmpty(leftover);
      if (more) {
        return core.suspend(() => loop);
      }
      return channel.zipRight(core.write(leftover), channel.identityChannel());
    })(Effect.map(Chunk.unsafeFromArray)(Effect.dropWhile(input, predicate)))),
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop));
});
/** @internal */
export const either = self => catchAll(error => make(Either.left(error)))(map(Either.right)(self));
/** @internal */
export const empty = /*#__PURE__*/new StreamImpl( /*#__PURE__*/core.write( /*#__PURE__*/Chunk.empty()));
/** @internal */
export const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => new StreamImpl(channel.ensuring(finalizer)(toChannel(self))));
/** @internal */
export const ensuringWith = /*#__PURE__*/dual(2, (self, finalizer) => new StreamImpl(core.ensuringWith(toChannel(self), finalizer)));
/** @internal */
export const context = () => fromEffect(Effect.context());
/** @internal */
export const contextWith = f => map(f)(context());
/** @internal */
export const contextWithEffect = f => mapEffectSequential(f)(context());
/** @internal */
export const contextWithStream = f => flatMap(f)(context());
/** @internal */
export const execute = effect => drain(fromEffect(effect));
/** @internal */
export const fail = error => fromEffectOption(Effect.fail(Option.some(error)));
/** @internal */
export const failSync = evaluate => fromEffectOption(Effect.failSync(() => Option.some(evaluate())));
/** @internal */
export const failCause = cause => fromEffect(Effect.failCause(cause));
/** @internal */
export const failCauseSync = evaluate => fromEffect(Effect.failCauseSync(evaluate));
/** @internal */
export const filter = /*#__PURE__*/dual(2, (self, predicate) => mapChunks(self, Chunk.filter(predicate)));
/** @internal */
export const filterEffect = /*#__PURE__*/dual(2, (self, f) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: input => loop(input[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      return channel.unwrap(Effect.map(bool => bool ? core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value))) : loop(iterator))(f(next.value)));
    }
  };
  return new StreamImpl(core.suspend(() => core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self))));
});
/** @internal */
export const filterMap = /*#__PURE__*/dual(2, (self, pf) => mapChunks(self, Chunk.filterMap(pf)));
/** @internal */
export const filterMapEffect = /*#__PURE__*/dual(2, (self, pf) => suspend(() => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: input => loop(input[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      return channel.unwrap(Option.match({
        onNone: () => Effect.sync(() => loop(iterator)),
        onSome: Effect.map(a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))
      })(pf(next.value)));
    }
  };
  return new StreamImpl(core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self)));
}));
/** @internal */
export const filterMapWhile = /*#__PURE__*/dual(2, (self, pf) => {
  const loop = core.readWith({
    onInput: input => {
      const mapped = Chunk.filterMapWhile(input, pf);
      if (mapped.length === input.length) {
        return core.flatMap(() => loop)(core.write(mapped));
      }
      return core.write(mapped);
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
export const filterMapWhileEffect = /*#__PURE__*/dual(2, (self, pf) => suspend(() => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: input => loop(input[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      return channel.unwrap(Option.match(pf(next.value), {
        onNone: () => Effect.succeed(core.unit),
        onSome: Effect.map(a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))
      }));
    }
  };
  return new StreamImpl(channel.pipeToOrFail(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self)));
}));
/** @internal */
export const finalizer = finalizer => acquireRelease(Effect.unit, () => finalizer);
/** @internal */
export const find = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => Option.match(Chunk.findFirst(input, predicate), {
      onNone: () => loop,
      onSome: n => core.write(Chunk.of(n))
    }),
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(loop)(toChannel(self)));
});
/** @internal */
export const findEffect = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => channel.unwrap(Effect.map(Option.match({
      onNone: () => loop,
      onSome: n => core.write(Chunk.of(n))
    }))(Effect.findFirst(input, predicate))),
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(loop)(toChannel(self)));
});
/** @internal */
export const flatMap = /*#__PURE__*/dual(args => typeof args[0] !== "function", (self, f, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), n => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(channel.concatMap(toChannel(self), as => Chunk.reduce(core.unit, (left, right) => channel.zipRight(right)(left))(Chunk.map(a => toChannel(f(a)))(as)))), n => new StreamImpl(channel.mergeMap(out => toChannel(f(out)), {
    concurrency: n,
    bufferSize
  })(channel.concatMap(channel.writeChunk)(toChannel(self)))));
});
/** @internal */
export const matchConcurrency = (concurrency, sequential, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential();
    case "unbounded":
      return bounded(Number.POSITIVE_INFINITY);
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential();
  }
};
const flatMapParSwitchBuffer = /*#__PURE__*/dual(4, (self, n, bufferSize, f) => new StreamImpl(channel.mergeMap(out => toChannel(f(out)), {
  concurrency: n,
  mergeStrategy: MergeStrategy.BufferSliding(),
  bufferSize
})(channel.concatMap(channel.writeChunk)(toChannel(self)))));
/** @internal */
export const flatten = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => flatMap(self, identity, options));
/** @internal */
export const flattenChunks = self => {
  const flatten = core.readWithCause({
    onInput: chunks => core.flatMap(channel.writeChunk(chunks), () => flatten),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(flatten)(toChannel(self)));
};
/** @internal */
export const flattenEffect = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => options?.unordered ? flatMap(self, a => fromEffect(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), n => new StreamImpl(channel.mapOut(Chunk.of)(channel.mapOutEffectPar(identity, n)(channel.concatMap(channel.writeChunk)(toChannel(self)))))));
/** @internal */
export const flattenExitOption = self => {
  const processChunk = (chunk, cont) => {
    const [toEmit, rest] = Chunk.splitWhere(exit => !Exit.isSuccess(exit))(chunk);
    const next = Option.match({
      onNone: () => cont,
      onSome: Exit.match({
        onFailure: cause => Option.match(Cause.flipCauseOption(cause), {
          onNone: () => core.unit,
          onSome: core.failCause
        }),
        onSuccess: () => core.unit
      })
    })(Chunk.head(rest));
    return core.flatMap(() => next)(core.write(Chunk.filterMap(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(toEmit)));
  };
  const process = core.readWithCause({
    onInput: chunk => processChunk(chunk, process),
    onFailure: cause => core.failCause(cause),
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(process)(toChannel(self)));
};
/** @internal */
export const flattenIterables = self => flattenChunks(map(Chunk.fromIterable)(self));
/** @internal */
export const flattenTake = self => flattenChunks(flattenExitOption(map(take => take.exit)(self)));
/** @internal */
export const forever = self => new StreamImpl(channel.repeated(toChannel(self)));
/** @internal */
export const fromAsyncIterable = (iterable, onError) => unwrapScoped(Effect.map(iterator => repeatEffectOption(Effect.flatMap(result => result.done ? Effect.fail(Option.none()) : Effect.succeed(result.value))(Effect.tryPromise({
  try: async () => iterator.next(),
  catch: reason => Option.some(onError(reason))
}))))(Effect.acquireRelease(Effect.sync(() => iterable[Symbol.asyncIterator]()), iterator => iterator.return ? Effect.promise(async () => iterator.return()) : Effect.unit)));
/** @internal */
export const fromChannel = channel => new StreamImpl(channel);
/** @internal */
export const toChannel = stream => {
  if (Effect.isEffect(stream)) {
    return toChannel(fromEffect(stream));
  }
  return stream.channel;
};
/** @internal */
export const fromChunk = chunk => new StreamImpl(Chunk.isEmpty(chunk) ? core.unit : core.write(chunk));
/** @internal */
export const fromChunkHub = (hub, options) => {
  if (options?.scoped) {
    const effect = Effect.map(Hub.subscribe(hub), fromChunkQueue);
    return options.shutdown ? Effect.map(effect, ensuring(Hub.shutdown(hub))) : effect;
  }
  const stream = flatMap(scoped(Hub.subscribe(hub)), fromChunkQueue);
  return options?.shutdown ? ensuring(stream, Hub.shutdown(hub)) : stream;
};
/** @internal */
export const fromChunkQueue = (queue, options) => (options?.shutdown ? ensuring(Queue.shutdown(queue)) : identity)(repeatEffectChunkOption(Effect.catchAllCause(cause => Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause))(Queue.isShutdown(queue)))(Queue.take(queue))));
/** @internal */
export const fromChunks = (...chunks) => flatMap(fromChunk)(fromIterable(chunks));
/** @internal */
export const fromEffect = effect => fromEffectOption(Effect.mapError(Option.some)(effect));
/** @internal */
export const fromEffectOption = effect => new StreamImpl(channel.unwrap(Effect.match(effect, {
  onFailure: Option.match({
    onNone: () => core.unit,
    onSome: core.fail
  }),
  onSuccess: a => core.write(Chunk.of(a))
})));
/** @internal */
export const fromHub = (hub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect = Effect.map(Hub.subscribe(hub), queue => fromQueue(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? Effect.map(effect, ensuring(Hub.shutdown(hub))) : effect;
  }
  const stream = flatMap(scoped(Hub.subscribe(hub)), queue => fromQueue(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring(stream, Hub.shutdown(hub)) : stream;
};
/** @internal */
export const fromIterable = iterable => suspend(() => Chunk.isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
/** @internal */
export const fromIterableEffect = effect => unwrap(Effect.map(fromIterable)(effect));
/** @internal */
export const fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return unwrap(Effect.sync(() => {
    let builder = [];
    const loop = iterator => channel.unwrap(Effect.sync(() => {
      let next = iterator.next();
      if (maxChunkSize === 1) {
        if (next.done) {
          return core.unit;
        }
        return core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value)));
      }
      builder = [];
      let count = 0;
      while (count < maxChunkSize && !next.done) {
        builder.push(next.value);
        next = iterator.next();
        count = count + 1;
      }
      if (count > 0) {
        return core.flatMap(() => loop(iterator))(core.write(Chunk.unsafeFromArray(builder)));
      }
      return core.unit;
    }));
    return new StreamImpl(loop(iterator));
  }));
};
/** @internal */
export const fromPull = effect => unwrapScoped(Effect.map(repeatEffectChunkOption)(effect));
/** @internal */
export const fromQueue = (queue, options) => (options?.shutdown ? ensuring(Queue.shutdown(queue)) : identity)(repeatEffectChunkOption(Effect.catchAllCause(cause => Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause))(Queue.isShutdown(queue)))(Queue.takeBetween(queue, 1, options?.maxChunkSize ?? DefaultChunkSize))));
/** @internal */
export const fromSchedule = schedule => unwrap(Effect.map(driver => repeatEffectOption(driver.next(void 0)))(Schedule.driver(schedule)));
/** @internal */
export const fromReadableStream = (evaluate, onError) => unwrapScoped(Effect.map(Effect.acquireRelease(Effect.sync(() => evaluate().getReader()), reader => Effect.promise(() => reader.cancel())), reader => repeatEffectOption(Effect.flatMap(Effect.tryPromise({
  try: () => reader.read(),
  catch: reason => Option.some(onError(reason))
}), ({
  done,
  value
}) => done ? Effect.fail(Option.none()) : Effect.succeed(value)))));
/** @internal */
export const fromReadableStreamByob = (evaluate, onError, allocSize = 4096) => unwrapScoped(Effect.map(Effect.acquireRelease(Effect.sync(() => evaluate().getReader({
  mode: "byob"
})), reader => Effect.promise(() => reader.cancel())), reader => catchAll(forever(readChunkStreamByobReader(reader, onError, allocSize)), error => typeof error === "object" && error !== null && "_tag" in error && error._tag === "EOF" ? empty : fail(error))));
const readChunkStreamByobReader = (reader, onError, size) => {
  const buffer = new ArrayBuffer(size);
  return paginateEffect(0, offset => Effect.flatMap(Effect.tryPromise({
    try: () => reader.read(new Uint8Array(buffer, offset, buffer.byteLength - offset)),
    catch: reason => onError(reason)
  }), ({
    done,
    value
  }) => {
    if (done) {
      return Effect.fail({
        _tag: "EOF"
      });
    }
    const newOffset = offset + value.byteLength;
    return Effect.succeed([value, newOffset >= buffer.byteLength ? Option.none() : Option.some(newOffset)]);
  }));
};
/** @internal */
export const groupAdjacentBy = /*#__PURE__*/dual(2, (self, f) => {
  const groupAdjacentByChunk = (state, chunk) => {
    if (Chunk.isEmpty(chunk)) {
      return [state, Chunk.empty()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = undefined;
    let previousChunk = Chunk.empty();
    switch (state._tag) {
      case "Some":
        {
          const tuple = state.value;
          key = tuple[0];
          let loop = true;
          while (loop && until < chunk.length) {
            const input = Chunk.unsafeGet(chunk, until);
            const updatedKey = f(input);
            if (!Equal.equals(key, updatedKey)) {
              builder.push([key, Chunk.unsafeFromArray(Array.from(tuple[1]).slice(from, until))]);
              key = updatedKey;
              from = until;
              loop = false;
            }
            until = until + 1;
          }
          if (loop) {
            previousChunk = tuple[1];
          }
          break;
        }
      case "None":
        {
          key = f(Chunk.unsafeGet(chunk, until));
          until = until + 1;
          break;
        }
    }
    while (until < chunk.length) {
      const input = Chunk.unsafeGet(chunk, until);
      const updatedKey = f(input);
      if (!Equal.equals(key, updatedKey)) {
        builder.push([key, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = Chunk.appendAll(previousChunk, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until)));
    const output = Chunk.unsafeFromArray(builder);
    return [Option.some([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = state => core.readWithCause({
    onInput: input => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return Chunk.isEmpty(output) ? groupAdjacent(updatedState) : core.flatMap(core.write(output), () => groupAdjacent(updatedState));
    },
    onFailure: cause => Option.match(state, {
      onNone: () => core.failCause(cause),
      onSome: output => core.flatMap(core.write(Chunk.of(output)), () => core.failCause(cause))
    }),
    onDone: done => Option.match(state, {
      onNone: () => core.succeedNow(done),
      onSome: output => core.flatMap(core.write(Chunk.of(output)), () => core.succeedNow(done))
    })
  });
  return new StreamImpl(channel.pipeToOrFail(toChannel(self), groupAdjacent(Option.none())));
});
/** @internal */
export const grouped = /*#__PURE__*/dual(2, (self, chunkSize) => chunks(rechunk(chunkSize)(self)));
/** @internal */
export const groupedWithin = /*#__PURE__*/dual(3, (self, chunkSize, duration) => aggregateWithin(self, _sink.collectAllN(chunkSize), Schedule.spaced(duration)));
/** @internal */
export const haltWhen = /*#__PURE__*/dual(2, (self, effect) => {
  const writer = fiber => channel.unwrap(Effect.map(Option.match({
    onNone: () => core.readWith({
      onInput: input => core.flatMap(core.write(input), () => writer(fiber)),
      onFailure: core.fail,
      onDone: () => core.unit
    }),
    onSome: Exit.match({
      onFailure: core.failCause,
      onSuccess: () => core.unit
    })
  }))(Fiber.poll(fiber)));
  return new StreamImpl(channel.unwrapScoped(Effect.map(fiber => core.pipeTo(writer(fiber))(toChannel(self)))(Effect.forkScoped(effect))));
});
/** @internal */
export const haltAfter = /*#__PURE__*/dual(2, (self, duration) => haltWhen(Clock.sleep(duration))(self));
/** @internal */
export const haltWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => {
  const writer = channel.unwrap(Effect.map(Option.match({
    onNone: () => core.readWith({
      onInput: input => core.flatMap(() => writer)(core.write(input)),
      onFailure: core.fail,
      onDone: () => core.unit
    }),
    onSome: effect => channel.unwrap(Effect.match(effect, {
      onFailure: core.fail,
      onSuccess: () => core.unit
    }))
  }))(Deferred.poll(deferred)));
  return new StreamImpl(core.pipeTo(writer)(toChannel(self)));
});
/** @internal */
export const identityStream = () => new StreamImpl(channel.identityChannel());
/** @internal */
export const interleave = /*#__PURE__*/dual(2, (self, that) => interleaveWith(that, forever(make(true, false)))(self));
/** @internal */
export const interleaveWith = /*#__PURE__*/dual(3, (self, that, decider) => {
  const producer = handoff => core.readWithCause({
    onInput: value => core.flatMap(core.fromEffect(Handoff.offer(handoff, _take.of(value))), () => producer(handoff)),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, _take.failCause(cause))),
    onDone: () => core.fromEffect(Handoff.offer(handoff, _take.end))
  });
  return new StreamImpl(channel.unwrapScoped(Effect.map(([left, right]) => {
    const process = (leftDone, rightDone) => core.readWithCause({
      onInput: bool => {
        if (bool && !leftDone) {
          return core.flatMap(_take.match({
            onEnd: () => rightDone ? core.unit : process(true, rightDone),
            onFailure: core.failCause,
            onSuccess: chunk => core.flatMap(() => process(leftDone, rightDone))(core.write(chunk))
          }))(core.fromEffect(Handoff.take(left)));
        }
        if (!bool && !rightDone) {
          return core.flatMap(_take.match({
            onEnd: () => leftDone ? core.unit : process(leftDone, true),
            onFailure: core.failCause,
            onSuccess: chunk => core.flatMap(() => process(leftDone, rightDone))(core.write(chunk))
          }))(core.fromEffect(Handoff.take(right)));
        }
        return process(leftDone, rightDone);
      },
      onFailure: core.failCause,
      onDone: () => core.unit
    });
    return core.pipeTo(process(false, false))(channel.concatMap(channel.writeChunk)(toChannel(decider)));
  })(Effect.tap(([_, right]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right))(channel.concatMap(channel.writeChunk)(toChannel(that))))))(Effect.tap(([left]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left))(channel.concatMap(channel.writeChunk)(toChannel(self))))))(Effect.zip(Handoff.make())(Handoff.make()))))));
});
/** @internal */
export const intersperse = /*#__PURE__*/dual(2, (self, element) => new StreamImpl(channel.pipeToOrFail(core.suspend(() => {
  const writer = isFirst => core.readWithCause({
    onInput: chunk => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element);
          builder.push(output);
        }
      }
      return core.flatMap(() => writer(flagResult))(core.write(Chunk.unsafeFromArray(builder)));
    },
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  return writer(true);
}))(toChannel(self))));
/** @internal */
export const intersperseAffixes = /*#__PURE__*/dual(2, (self, {
  end,
  middle,
  start
}) => concat(make(end))(concat(intersperse(middle)(self))(make(start))));
/** @internal */
export const interruptAfter = /*#__PURE__*/dual(2, (self, duration) => interruptWhen(Clock.sleep(duration))(self));
/** @internal */
export const interruptWhen = /*#__PURE__*/dual(2, (self, effect) => new StreamImpl(channel.interruptWhen(effect)(toChannel(self))));
/** @internal */
export const interruptWhenDeferred = /*#__PURE__*/dual(2, (self, deferred) => new StreamImpl(channel.interruptWhenDeferred(deferred)(toChannel(self))));
/** @internal */
export const iterate = (value, next) => unfold(value, a => Option.some([a, next(a)]));
/** @internal */
export const make = (...as) => fromIterable(as);
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(channel.mapOut(Chunk.map(f))(toChannel(self))));
/** @internal */
export const mapAccum = /*#__PURE__*/dual(3, (self, s, f) => {
  const accumulator = s => core.readWith({
    onInput: input => {
      const [nextS, chunk] = Chunk.mapAccum(input, s, f);
      return core.flatMap(core.write(chunk), () => accumulator(nextS));
    },
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(core.pipeTo(accumulator(s))(toChannel(self)));
});
/** @internal */
export const mapAccumEffect = /*#__PURE__*/dual(3, (self, s, f) => suspend(() => {
  const accumulator = s => core.readWith({
    onInput: input => channel.unwrap(Effect.suspend(() => {
      const outputs = [];
      const emit = output => Effect.sync(() => {
        outputs.push(output);
      });
      return Effect.match({
        onFailure: error => {
          if (outputs.length !== 0) {
            return channel.zipRight(core.write(Chunk.unsafeFromArray(outputs)), core.fail(error));
          }
          return core.fail(error);
        },
        onSuccess: s => core.flatMap(core.write(Chunk.unsafeFromArray(outputs)), () => accumulator(s))
      })(Effect.reduce(s, (s, a) => Effect.flatMap(([s, a]) => Effect.as(s)(emit(a)))(f(s, a)))(input));
    })),
    onFailure: core.fail,
    onDone: () => core.unit
  });
  return new StreamImpl(channel.pipeToOrFail(accumulator(s))(toChannel(self)));
}));
/** @internal */
export const mapBoth = /*#__PURE__*/dual(3, (self, f, g) => map(g)(mapError(f)(self)));
/** @internal */
export const mapChunks = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(channel.mapOut(f)(toChannel(self))));
/** @internal */
export const mapChunksEffect = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(channel.mapOutEffect(f)(toChannel(self))));
/** @internal */
export const mapConcat = /*#__PURE__*/dual(2, (self, f) => mapConcatChunk(a => Chunk.fromIterable(f(a)))(self));
/** @internal */
export const mapConcatChunk = /*#__PURE__*/dual(2, (self, f) => mapChunks(Chunk.flatMap(f))(self));
/** @internal */
export const mapConcatChunkEffect = /*#__PURE__*/dual(2, (self, f) => mapConcatChunk(identity)(mapEffectSequential(f)(self)));
/** @internal */
export const mapConcatEffect = /*#__PURE__*/dual(2, (self, f) => mapConcatChunk(identity)(mapEffectSequential(a => Effect.map(Chunk.fromIterable)(f(a)))(self)));
/** @internal */
export const mapEffectSequential = /*#__PURE__*/dual(2, (self, f) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: elem => loop(elem[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      const value = next.value;
      return channel.unwrap(Effect.map(f(value), a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator))));
    }
  };
  return new StreamImpl(core.pipeTo(core.suspend(() => loop(Chunk.empty()[Symbol.iterator]())))(toChannel(self)));
});
/** @internal */
export const mapEffectPar = /*#__PURE__*/dual(3, (self, n, f) => new StreamImpl(channel.mapOut(Chunk.of)(channel.mapOutEffectPar(f, n)(channel.concatMap(channel.writeChunk)(toChannel(self))))));
/** @internal */
export const mapError = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(channel.mapError(f)(toChannel(self))));
/** @internal */
export const mapErrorCause = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(channel.mapErrorCause(f)(toChannel(self))));
/** @internal */
export const merge = /*#__PURE__*/dual(args => isStream(args[1]), (self, that, options) => mergeWith(self, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
/** @internal */
export const mergeAll = /*#__PURE__*/dual(args => Symbol.iterator in args[0], (streams, options) => flatten(fromIterable(streams), options));
/** @internal */
export const mergeEither = /*#__PURE__*/dual(2, (self, that) => mergeWith(self, that, {
  onSelf: Either.left,
  onOther: Either.right
}));
/** @internal */
export const mergeLeft = /*#__PURE__*/dual(2, (self, that) => merge(drain(that))(self));
/** @internal */
export const mergeRight = /*#__PURE__*/dual(2, (self, that) => merge(that)(drain(self)));
/** @internal */
export const mergeWith = /*#__PURE__*/dual(3, (self, other, options) => {
  const strategy = options.haltStrategy ? haltStrategy.fromInput(options.haltStrategy) : HaltStrategy.Both;
  const handler = terminate => exit => terminate || !Exit.isSuccess(exit) ?
  // TODO: remove
  MergeDecision.Done(Effect.suspend(() => exit)) : MergeDecision.Await(exit => Effect.suspend(() => exit));
  return new StreamImpl(channel.mergeWith(toChannel(map(self, options.onSelf)), {
    other: toChannel(map(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
/** @internal */
export const mkString = self => run(self, _sink.mkString);
/** @internal */
export const never = /*#__PURE__*/fromEffect(Effect.never);
/** @internal */
export const onError = /*#__PURE__*/dual(2, (self, cleanup) => catchAllCause(cause => fromEffect(Effect.zipRight(Effect.failCause(cause))(cleanup(cause))))(self));
/** @internal */
export const onDone = /*#__PURE__*/dual(2, (self, cleanup) => new StreamImpl(core.ensuringWith(exit => Exit.isSuccess(exit) ? cleanup() : Effect.unit)(toChannel(self))));
/** @internal */
export const orDie = self => orDieWith(identity)(self);
/** @internal */
export const orDieWith = /*#__PURE__*/dual(2, (self, f) => new StreamImpl(channel.orDieWith(f)(toChannel(self))));
/** @internal */
export const orElse = /*#__PURE__*/dual(2, (self, that) => new StreamImpl(channel.orElse(() => toChannel(that()))(toChannel(self))));
/** @internal */
export const orElseEither = /*#__PURE__*/dual(2, (self, that) => orElse(() => map(Either.right)(that()))(map(Either.left)(self)));
/** @internal */
export const orElseFail = /*#__PURE__*/dual(2, (self, error) => orElse(() => failSync(error))(self));
/** @internal */
export const orElseIfEmpty = /*#__PURE__*/dual(2, (self, element) => orElseIfEmptyChunk(() => Chunk.of(element()))(self));
/** @internal */
export const orElseIfEmptyChunk = /*#__PURE__*/dual(2, (self, chunk) => orElseIfEmptyStream(() => new StreamImpl(core.write(chunk())))(self));
/** @internal */
export const orElseIfEmptyStream = /*#__PURE__*/dual(2, (self, stream) => {
  const writer = core.readWith({
    onInput: input => {
      if (Chunk.isEmpty(input)) {
        return core.suspend(() => writer);
      }
      return channel.zipRight(channel.identityChannel())(core.write(input));
    },
    onFailure: core.fail,
    onDone: () => core.suspend(() => toChannel(stream()))
  });
  return new StreamImpl(core.pipeTo(writer)(toChannel(self)));
});
/** @internal */
export const orElseSucceed = /*#__PURE__*/dual(2, (self, value) => orElse(() => sync(value))(self));
/** @internal */
export const paginate = (s, f) => paginateChunk(s, s => {
  const page = f(s);
  return [Chunk.of(page[0]), page[1]];
});
/** @internal */
export const paginateChunk = (s, f) => {
  const loop = s => {
    const page = f(s);
    return Option.match(page[1], {
      onNone: () => channel.zipRight(core.write(page[0]), core.unit),
      onSome: s => core.flatMap(core.write(page[0]), () => loop(s))
    });
  };
  return new StreamImpl(core.suspend(() => loop(s)));
};
/** @internal */
export const paginateChunkEffect = (s, f) => {
  const loop = s => channel.unwrap(Effect.map(f(s), ([chunk, option]) => Option.match(option, {
    onNone: () => channel.zipRight(core.write(chunk), core.unit),
    onSome: s => core.flatMap(core.write(chunk), () => loop(s))
  })));
  return new StreamImpl(core.suspend(() => loop(s)));
};
/** @internal */
export const paginateEffect = (s, f) => paginateChunkEffect(s, s => Effect.map(([a, s]) => [Chunk.of(a), s])(f(s)));
/** @internal */
export const peel = /*#__PURE__*/dual(2, (self, sink) => {
  const OP_EMIT = "Emit";
  const OP_HALT = "Halt";
  const OP_END = "End";
  return Effect.flatten(Effect.flatMap(deferred => Effect.map(handoff => {
    const consumer = _sink.foldSink(_sink.collectLeftover(sink), {
      onFailure: error => _sink.zipRight(_sink.fromEffect(Deferred.fail(deferred, error)), _sink.fail(error)),
      onSuccess: ([z, leftovers]) => {
        const loop = core.readWithCause({
          onInput: elements => core.flatMap(core.fromEffect(Handoff.offer(handoff, {
            _tag: OP_EMIT,
            elements
          })), () => loop),
          onFailure: cause => channel.zipRight(core.fromEffect(Handoff.offer(handoff, {
            _tag: OP_HALT,
            cause
          })), core.failCause(cause)),
          onDone: _ => channel.zipRight(core.fromEffect(Handoff.offer(handoff, {
            _tag: OP_END
          })), core.unit)
        });
        return _sink.fromChannel(channel.zipRight(loop)(channel.zipRight(core.fromEffect(Handoff.offer({
          _tag: OP_EMIT,
          elements: leftovers
        })(handoff)))(core.fromEffect(Deferred.succeed(deferred, z)))));
      }
    });
    const producer = channel.unwrap(Effect.map(signal => {
      switch (signal._tag) {
        case OP_EMIT:
          {
            return core.flatMap(() => producer)(core.write(signal.elements));
          }
        case OP_HALT:
          {
            return core.failCause(signal.cause);
          }
        case OP_END:
          {
            return core.unit;
          }
      }
    })(Handoff.take(handoff)));
    return Effect.map(z => [z, new StreamImpl(producer)])(Effect.zipRight(Deferred.await(deferred))(Effect.forkScoped(run(consumer)(tapErrorCause(cause => Deferred.failCause(deferred, cause))(self)))));
  })(Handoff.make()))(Deferred.make()));
});
/** @internal */
export const partition = /*#__PURE__*/dual(args => typeof args[1] === "function", (self, predicate, options) => partitionEither(self, a => Effect.succeed(predicate(a) ? Either.left(a) : Either.right(a)), options));
/** @internal */
export const partitionEither = /*#__PURE__*/dual(args => typeof args[1] === "function", (self, predicate, options) => Effect.flatMap(([queue1, queue2]) => Effect.succeed([filterMap(flattenExitOption(fromQueue(queue1, {
  shutdown: true
})), _ => Either.match(_, {
  onLeft: Option.some,
  onRight: Option.none
})), filterMap(flattenExitOption(fromQueue(queue2, {
  shutdown: true
})), _ => Either.match(_, {
  onLeft: Option.none,
  onRight: Option.some
}))]))(distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: Either.match({
    onLeft: () => Effect.succeed(n => n === 0),
    onRight: () => Effect.succeed(n => n === 1)
  })
})(mapEffectSequential(self, predicate))));
/** @internal */
export const pipeThrough = /*#__PURE__*/dual(2, (self, sink) => new StreamImpl(channel.pipeToOrFail(_sink.toChannel(sink))(toChannel(self))));
/** @internal */
export const pipeThroughChannel = /*#__PURE__*/dual(2, (self, channel) => new StreamImpl(core.pipeTo(channel)(toChannel(self))));
/** @internal */
export const pipeThroughChannelOrFail = /*#__PURE__*/dual(2, (self, chan) => new StreamImpl(channel.pipeToOrFail(chan)(toChannel(self))));
/** @internal */
export const prepend = values => new StreamImpl(channel.zipRight(channel.identityChannel())(core.write(values)));
/** @internal */
export const provideContext = /*#__PURE__*/dual(2, (self, context) => new StreamImpl(core.provideContext(context)(toChannel(self))));
/** @internal */
export const provideLayer = /*#__PURE__*/dual(2, (self, layer) => new StreamImpl(channel.unwrapScoped(Effect.map(env => core.provideContext(env)(toChannel(self)))(Layer.build(layer)))));
/** @internal */
export const provideService = /*#__PURE__*/dual(3, (self, tag, resource) => provideServiceEffect(self, tag, Effect.succeed(resource)));
/** @internal */
export const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => provideServiceStream(self, tag, fromEffect(effect)));
/** @internal */
export const provideServiceStream = /*#__PURE__*/dual(3, (self, tag, stream) => contextWithStream(env => flatMap(stream, service => provideContext(Context.add(env, tag, service))(self))));
/** @internal */
export const contramapContext = /*#__PURE__*/dual(2, (self, f) => contextWithStream(env => provideContext(f(env))(self)));
/** @internal */
export const provideSomeLayer = /*#__PURE__*/dual(2, (self, layer) => // @ts-expect-error
provideLayer(Layer.merge(layer)(Layer.context()))(self));
/** @internal */
export const range = (min, max, chunkSize = DefaultChunkSize) => suspend(() => {
  if (min >= max) {
    return empty;
  }
  const go = (min, max, chunkSize) => {
    const remaining = max - min;
    if (remaining > chunkSize) {
      return core.flatMap(() => go(min + chunkSize, max, chunkSize))(core.write(Chunk.range(min, min + chunkSize - 1)));
    }
    return core.write(Chunk.range(min, min + remaining - 1));
  };
  return new StreamImpl(go(min, max, chunkSize));
});
/** @internal */
export const rechunk = /*#__PURE__*/dual(2, (self, n) => suspend(() => {
  const target = Math.max(n, 1);
  const process = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(core.pipeTo(process)(toChannel(self)));
}));
/** @internal */
const rechunkProcess = (rechunker, target) => core.readWithCause({
  onInput: chunk => {
    if (chunk.length === target && rechunker.isEmpty()) {
      return core.flatMap(core.write(chunk), () => rechunkProcess(rechunker, target));
    }
    if (chunk.length > 0) {
      const chunks = [];
      let result = undefined;
      let index = 0;
      while (index < chunk.length) {
        while (index < chunk.length && result === undefined) {
          result = rechunker.write(Chunk.unsafeGet(index)(chunk));
          index = index + 1;
        }
        if (result !== undefined) {
          chunks.push(result);
          result = undefined;
        }
      }
      return core.flatMap(channel.writeAll(...chunks), () => rechunkProcess(rechunker, target));
    }
    return core.suspend(() => rechunkProcess(rechunker, target));
  },
  onFailure: cause => channel.zipRight(rechunker.emitIfNotEmpty(), core.failCause(cause)),
  onDone: () => rechunker.emitIfNotEmpty()
});
/** @internal */
class StreamRechunker {
  constructor(n) {
    this.n = n;
    this.builder = [];
    this.pos = 0;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = Chunk.unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return undefined;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return core.write(Chunk.unsafeFromArray(this.builder));
    }
    return core.unit;
  }
}
/** @internal */
export const refineOrDie = /*#__PURE__*/dual(2, (self, pf) => refineOrDieWith(pf, identity)(self));
/** @internal */
export const refineOrDieWith = /*#__PURE__*/dual(3, (self, pf, f) => new StreamImpl(channel.catchAll(toChannel(self), error => Option.match(pf(error), {
  onNone: () => core.failCause(Cause.die(f(error))),
  onSome: core.fail
}))));
/** @internal */
export const repeat = /*#__PURE__*/dual(2, (self, schedule) => filterMap(repeatEither(self, schedule), _ => Either.match(_, {
  onLeft: Option.none,
  onRight: Option.some
})));
/** @internal */
export const repeatEffect = effect => repeatEffectOption(Effect.mapError(Option.some)(effect));
/** @internal */
export const repeatEffectChunk = effect => repeatEffectChunkOption(Effect.mapError(Option.some)(effect));
/** @internal */
export const repeatEffectChunkOption = effect => unfoldChunkEffect(effect, effect => Effect.catchAll(Option.match({
  onNone: () => Effect.succeed(Option.none()),
  onSome: Effect.fail
}))(Effect.map(effect, chunk => Option.some([chunk, effect]))));
/** @internal */
export const repeatEffectOption = effect => repeatEffectChunkOption(Effect.map(Chunk.of)(effect));
/** @internal */
export const repeatEither = /*#__PURE__*/dual(2, (self, schedule) => repeatWith(self, schedule, {
  onElement: a => Either.right(a),
  onSchedule: Either.left
}));
/** @internal */
export const repeatElements = /*#__PURE__*/dual(2, (self, schedule) => filterMap(repeatElementsWith(self, schedule, {
  onElement: a => Option.some(a),
  onSchedule: Option.none
}), identity));
/** @internal */
export const repeatElementsWith = /*#__PURE__*/dual(3, (self, schedule, options) => {
  const driver = channel.unwrap(Effect.map(driver => {
    const feed = input => Option.match(Chunk.head(input), {
      onNone: () => loop,
      onSome: a => channel.zipRight(core.write(Chunk.of(options.onElement(a))), step(Chunk.drop(1)(input), a))
    });
    const step = (input, a) => {
      const advance = Effect.as(core.flatMap(() => step(input, a))(core.write(Chunk.of(options.onElement(a)))))(driver.next(a));
      const reset = Effect.flatMap(b => Effect.map(() => channel.zipRight(feed(input))(core.write(Chunk.of(options.onSchedule(b)))))(driver.reset()))(Effect.orDie(driver.last()));
      return channel.unwrap(Effect.orElse(() => reset)(advance));
    };
    const loop = core.readWith({
      onInput: feed,
      onFailure: core.fail,
      onDone: () => core.unit
    });
    return loop;
  })(Schedule.driver(schedule)));
  return new StreamImpl(core.pipeTo(driver)(toChannel(self)));
});
/** @internal */
export const repeatValue = value => new StreamImpl(channel.repeated(core.write(Chunk.of(value))));
/** @internal */
export const repeatWith = /*#__PURE__*/dual(3, (self, schedule, options) => {
  return unwrap(Effect.map(driver => {
    const scheduleOutput = Effect.map(options.onSchedule)(Effect.orDie(driver.last()));
    const process = toChannel(map(options.onElement)(self));
    const loop = channel.unwrap(Effect.match(driver.next(void 0), {
      onFailure: () => core.unit,
      onSuccess: () => channel.zipRight(channel.unwrap(Effect.map(c => core.flatMap(() => loop)(core.write(Chunk.of(c))))(scheduleOutput)))(process)
    }));
    return new StreamImpl(channel.zipRight(loop)(process));
  })(Schedule.driver(schedule)));
});
/**
 * Repeats the value using the provided schedule.
 *
 * @since 1.0.0
 * @category constructors
 */
export const repeatWithSchedule = (value, schedule) => repeatEffectWithSchedule(Effect.succeed(value), schedule);
/** @internal */
export const repeatEffectWithSchedule = (effect, schedule) => flatMap(fromEffect(Effect.zip(effect, Schedule.driver(schedule))), ([a, driver]) => concat(succeed(a), unfoldEffect(a, s => Effect.matchEffect(driver.next(s), {
  onFailure: Effect.succeed,
  onSuccess: () => Effect.map(effect, nextA => Option.some([nextA, nextA]))
}))));
/** @internal */
export const retry = /*#__PURE__*/dual(2, (self, schedule) => unwrap(Effect.map(Schedule.driver(schedule), driver => {
  const loop = catchAll(self, error => unwrap(Effect.matchEffect(driver.next(error), {
    onFailure: () => Effect.fail(error),
    onSuccess: () => Effect.succeed(tap(() => driver.reset())(loop))
  })));
  return loop;
})));
/** @internal */
export const run = /*#__PURE__*/dual(2, (self, sink) => channel.runDrain(channel.pipeToOrFail(_sink.toChannel(sink))(toChannel(self))));
/** @internal */
export const runCollect = self => run(_sink.collectAll())(self);
/** @internal */
export const runCount = self => run(_sink.count)(self);
/** @internal */
export const runDrain = self => run(_sink.drain)(self);
/** @internal */
export const runFold = /*#__PURE__*/dual(3, (self, s, f) => Effect.scoped(runFoldWhileScoped(s, constTrue, f)(self)));
/** @internal */
export const runFoldEffect = /*#__PURE__*/dual(3, (self, s, f) => Effect.scoped(runFoldWhileScopedEffect(s, constTrue, f)(self)));
/** @internal */
export const runFoldScoped = /*#__PURE__*/dual(3, (self, s, f) => runFoldWhileScoped(s, constTrue, f)(self));
/** @internal */
export const runFoldScopedEffect = /*#__PURE__*/dual(3, (self, s, f) => runFoldWhileScopedEffect(s, constTrue, f)(self));
/** @internal */
export const runFoldWhile = /*#__PURE__*/dual(4, (self, s, cont, f) => Effect.scoped(runFoldWhileScoped(s, cont, f)(self)));
/** @internal */
export const runFoldWhileEffect = /*#__PURE__*/dual(4, (self, s, cont, f) => Effect.scoped(runFoldWhileScopedEffect(s, cont, f)(self)));
/** @internal */
export const runFoldWhileScoped = /*#__PURE__*/dual(4, (self, s, cont, f) => runScoped(_sink.fold(s, cont, f))(self));
/** @internal */
export const runFoldWhileScopedEffect = /*#__PURE__*/dual(4, (self, s, cont, f) => runScoped(_sink.foldEffect(s, cont, f))(self));
/** @internal */
export const runForEach = /*#__PURE__*/dual(2, (self, f) => run(_sink.forEach(f))(self));
/** @internal */
export const runForEachChunk = /*#__PURE__*/dual(2, (self, f) => run(_sink.forEachChunk(f))(self));
/** @internal */
export const runForEachChunkScoped = /*#__PURE__*/dual(2, (self, f) => runScoped(_sink.forEachChunk(f))(self));
/** @internal */
export const runForEachScoped = /*#__PURE__*/dual(2, (self, f) => runScoped(_sink.forEach(f))(self));
/** @internal */
export const runForEachWhile = /*#__PURE__*/dual(2, (self, f) => run(_sink.forEachWhile(f))(self));
/** @internal */
export const runForEachWhileScoped = /*#__PURE__*/dual(2, (self, f) => runScoped(_sink.forEachWhile(f))(self));
/** @internal */
export const runHead = self => run(_sink.head())(self);
/** @internal */
export const runIntoHub = /*#__PURE__*/dual(2, (self, hub) => runIntoQueue(hub)(self));
/** @internal */
export const runIntoHubScoped = /*#__PURE__*/dual(2, (self, hub) => runIntoQueueScoped(hub)(self));
/** @internal */
export const runIntoQueue = /*#__PURE__*/dual(2, (self, queue) => Effect.scoped(runIntoQueueScoped(queue)(self)));
/** @internal */
export const runIntoQueueElementsScoped = /*#__PURE__*/dual(2, (self, queue) => {
  const writer = core.readWithCause({
    onInput: input => core.flatMap(core.fromEffect(Queue.offerAll(queue, Chunk.map(input, Exit.succeed))), () => writer),
    onFailure: cause => core.fromEffect(Queue.offer(queue, Exit.failCause(Cause.map(cause, Option.some)))),
    onDone: () => core.fromEffect(Queue.offer(queue, Exit.fail(Option.none())))
  });
  return Effect.asUnit(channelExecutor.runScoped(channel.drain(core.pipeTo(toChannel(self), writer))));
});
/** @internal */
export const runIntoQueueScoped = /*#__PURE__*/dual(2, (self, queue) => {
  const writer = core.readWithCause({
    onInput: input => core.flatMap(core.write(_take.chunk(input)), () => writer),
    onFailure: cause => core.write(_take.failCause(cause)),
    onDone: () => core.write(_take.end)
  });
  return Effect.asUnit(channelExecutor.runScoped(channel.drain(channel.mapOutEffect(take => Queue.offer(queue, take))(core.pipeTo(toChannel(self), writer)))));
});
/** @internal */
export const runLast = self => run(_sink.last())(self);
/** @internal */
export const runScoped = /*#__PURE__*/dual(2, (self, sink) => channelExecutor.runScoped(channel.drain(channel.pipeToOrFail(_sink.toChannel(sink))(toChannel(self)))));
/** @internal */
export const runSum = self => run(_sink.sum)(self);
/** @internal */
export const scan = /*#__PURE__*/dual(3, (self, s, f) => scanEffect(s, (s, a) => Effect.succeed(f(s, a)))(self));
/** @internal */
export const scanReduce = /*#__PURE__*/dual(2, (self, f) => scanReduceEffect((a2, a) => Effect.succeed(f(a2, a)))(self));
/** @internal */
export const scanReduceEffect = /*#__PURE__*/dual(2, (self, f) => mapAccumEffect(Option.none(), (option, a) => {
  switch (option._tag) {
    case "None":
      {
        return Effect.succeed([Option.some(a), a]);
      }
    case "Some":
      {
        return Effect.map(b => [Option.some(b), b])(f(option.value, a));
      }
  }
})(self));
/** @internal */
export const schedule = /*#__PURE__*/dual(2, (self, schedule) => filterMap(scheduleWith(self, schedule, {
  onElement: Option.some,
  onSchedule: Option.none
}), identity));
/** @internal */
export const scheduleWith = /*#__PURE__*/dual(3, (self, schedule, options) => {
  const loop = (driver, iterator) => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: chunk => loop(driver, chunk[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeedNow
      });
    }
    return channel.unwrap(Effect.matchEffect(driver.next(next.value), {
      onFailure: () => Effect.zipLeft(driver.reset())(Effect.map(b => core.flatMap(() => loop(driver, iterator))(core.write(Chunk.make(options.onElement(next.value), options.onSchedule(b)))))(Effect.orDie(driver.last()))),
      onSuccess: () => Effect.succeed(core.flatMap(() => loop(driver, iterator))(core.write(Chunk.of(options.onElement(next.value)))))
    }));
  };
  return new StreamImpl(core.flatMap(driver => core.pipeTo(loop(driver, Chunk.empty()[Symbol.iterator]()))(toChannel(self)))(core.fromEffect(Schedule.driver(schedule))));
});
/** @internal */
export const scanEffect = /*#__PURE__*/dual(3, (self, s, f) => new StreamImpl(core.flatMap(() => toChannel(mapAccumEffect(s, (s, a) => Effect.map(s => [s, s])(f(s, a)))(self)))(core.write(Chunk.of(s)))));
/** @internal */
export const scoped = effect => new StreamImpl(channel.ensuring(channel.scoped(Effect.map(Chunk.of)(effect)), Effect.unit));
/** @internal */
export const some = self => someOrFail(() => Option.none())(mapError(Option.some)(self));
/** @internal */
export const someOrElse = /*#__PURE__*/dual(2, (self, fallback) => map(Option.getOrElse(fallback))(self));
/** @internal */
export const someOrFail = /*#__PURE__*/dual(2, (self, error) => mapEffectSequential(self, Option.match({
  onNone: () => Effect.failSync(error),
  onSome: Effect.succeed
})));
/** @internal */
export const sliding = /*#__PURE__*/dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
/** @internal */
export const slidingSize = /*#__PURE__*/dual(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die(Cause.IllegalArgumentException("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(core.suspend(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result = Chunk.isEmpty(items) ? Chunk.empty() : Chunk.of(items);
        return core.flatMap(() => channelEnd)(core.write(result));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = Chunk.takeRight(leftovers)(queue.toChunk());
      const result = Chunk.isEmpty(lastItems) ? Chunk.empty() : Chunk.of(lastItems);
      return core.flatMap(() => channelEnd)(core.write(result));
    };
    const reader = queueSize => core.readWithCause({
      onInput: input => core.flatMap(core.write(Chunk.filterMap(input, (element, index) => {
        queue.put(element);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return Option.none();
        }
        return Option.some(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: cause => emitOnStreamEnd(queueSize, core.failCause(cause)),
      onDone: () => emitOnStreamEnd(queueSize, core.unit)
    });
    return core.pipeTo(reader(0))(toChannel(self));
  }));
});
/** @internal */
export const split = /*#__PURE__*/dual(2, (self, predicate) => {
  const split = (leftovers, input) => {
    const [chunk, remaining] = Chunk.splitWhere(predicate)(Chunk.appendAll(input)(leftovers));
    if (Chunk.isEmpty(chunk) || Chunk.isEmpty(remaining)) {
      return loop(Chunk.appendAll(Chunk.drop(1)(remaining))(chunk));
    }
    return core.flatMap(() => split(Chunk.empty(), Chunk.drop(1)(remaining)))(core.write(Chunk.of(chunk)));
  };
  const loop = leftovers => core.readWith({
    onInput: input => split(leftovers, input),
    onFailure: core.fail,
    onDone: () => {
      if (Chunk.isEmpty(leftovers)) {
        return core.unit;
      }
      if (Option.isNone(Chunk.findFirst(predicate)(leftovers))) {
        return channel.zipRight(core.write(Chunk.of(leftovers)), core.unit);
      }
      return channel.zipRight(split(Chunk.empty(), leftovers), core.unit);
    }
  });
  return new StreamImpl(core.pipeTo(loop(Chunk.empty()))(toChannel(self)));
});
/** @internal */
export const splitOnChunk = /*#__PURE__*/dual(2, (self, delimiter) => {
  const next = (leftover, delimiterIndex) => core.readWithCause({
    onInput: inputChunk => {
      let buffer;
      const [carry, delimiterCursor] = Chunk.reduce([Option.getOrElse(() => Chunk.empty())(leftover), delimiterIndex], ([carry, delimiterCursor], a) => {
        const concatenated = Chunk.append(a)(carry);
        if (delimiterCursor < delimiter.length && Equal.equals(a, Chunk.unsafeGet(delimiterCursor)(delimiter))) {
          if (delimiterCursor + 1 === delimiter.length) {
            if (buffer === undefined) {
              buffer = [];
            }
            buffer.push(Chunk.take(concatenated.length - delimiter.length)(concatenated));
            return [Chunk.empty(), 0];
          }
          return [concatenated, delimiterCursor + 1];
        }
        return [concatenated, Equal.equals(a, Chunk.unsafeGet(0)(delimiter)) ? 1 : 0];
      })(inputChunk);
      const output = buffer === undefined ? Chunk.empty() : Chunk.unsafeFromArray(buffer);
      return core.flatMap(core.write(output), () => next(Chunk.isNonEmpty(carry) ? Option.some(carry) : Option.none(), delimiterCursor));
    },
    onFailure: cause => Option.match(leftover, {
      onNone: () => core.failCause(cause),
      onSome: chunk => channel.zipRight(core.write(Chunk.of(chunk)), core.failCause(cause))
    }),
    onDone: done => Option.match(leftover, {
      onNone: () => core.succeed(done),
      onSome: chunk => channel.zipRight(core.write(Chunk.of(chunk)), core.succeed(done))
    })
  });
  return new StreamImpl(core.pipeTo(next(Option.none(), 0))(toChannel(self)));
});
/** @internal */
export const splitLines = self => suspend(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = chunk => {
    const chunkBuilder = [];
    Chunk.map(chunk, str => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return Chunk.unsafeFromArray(chunkBuilder);
  };
  const loop = core.readWithCause({
    onInput: input => {
      const out = splitLinesChunk(input);
      return Chunk.isEmpty(out) ? loop : core.flatMap(core.write(out), () => loop);
    },
    onFailure: cause => stringBuilder.length === 0 ? core.failCause(cause) : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.failCause(cause)),
    onDone: done => stringBuilder.length === 0 ? core.succeed(done) : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.succeed(done))
  });
  return new StreamImpl(core.pipeTo(toChannel(self), loop));
});
/** @internal */
export const succeed = value => fromChunk(Chunk.of(value));
/** @internal */
export const sync = evaluate => suspend(() => fromChunk(Chunk.of(evaluate())));
/** @internal */
export const suspend = stream => new StreamImpl(core.suspend(() => toChannel(stream())));
/** @internal */
export const take = /*#__PURE__*/dual(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die(Cause.IllegalArgumentException(`${n} must be an integer`));
  }
  const loop = n => core.readWith({
    onInput: input => {
      const taken = Chunk.take(Math.min(n, Number.POSITIVE_INFINITY))(input);
      const leftover = Math.max(0, n - taken.length);
      const more = leftover > 0;
      if (more) {
        return core.flatMap(() => loop(leftover))(core.write(taken));
      }
      return core.write(taken);
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl(channel.pipeToOrFail(0 < n ? loop(n) : core.unit)(toChannel(self)));
});
/** @internal */
export const takeRight = /*#__PURE__*/dual(2, (self, n) => {
  if (n <= 0) {
    return empty;
  }
  return new StreamImpl(channel.unwrap(Effect.map(queue => {
    const reader = core.readWith({
      onInput: input => {
        for (const element of input) {
          queue.put(element);
        }
        return reader;
      },
      onFailure: core.fail,
      onDone: () => channel.zipRight(core.unit)(core.write(queue.toChunk()))
    });
    return core.pipeTo(reader)(toChannel(self));
  })(Effect.succeed(new RingBuffer(n)))));
});
/** @internal */
export const takeUntil = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => {
      const taken = Chunk.takeWhile(a => !predicate(a))(input);
      const last = Chunk.take(1)(Chunk.drop(taken.length)(input));
      if (Chunk.isEmpty(last)) {
        return core.flatMap(() => loop)(core.write(taken));
      }
      return core.write(Chunk.appendAll(last)(taken));
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
export const takeUntilEffect = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: elem => loop(elem[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    }
    return channel.unwrap(Effect.map(bool => bool ? core.write(Chunk.of(next.value)) : core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value))))(predicate(next.value)));
  };
  return new StreamImpl(core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self)));
});
/** @internal */
export const takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => {
      const taken = Chunk.takeWhile(predicate)(input);
      const more = taken.length === input.length;
      if (more) {
        return core.flatMap(() => loop)(core.write(taken));
      }
      return core.write(taken);
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
export const tap = /*#__PURE__*/dual(2, (self, f) => mapEffectSequential(self, a => Effect.as(f(a), a)));
/** @internal */
export const tapError = /*#__PURE__*/dual(2, (self, f) => catchAll(self, error => fromEffect(Effect.zipRight(f(error), Effect.fail(error)))));
/** @internal */
export const tapErrorCause = /*#__PURE__*/dual(2, (self, f) => catchAllCause(self, cause => fromEffect(Effect.zipRight(f(cause), Effect.failCause(cause)))));
/** @internal */
export const tapSink = /*#__PURE__*/dual(2, (self, sink) => flatMap(([queue, deferred]) => {
  const right = flattenTake(fromQueue(queue, {
    maxChunkSize: 1
  }));
  const loop = core.readWithCause({
    onInput: chunk => core.foldCauseChannel({
      onFailure: () => core.flatMap(core.write(chunk), () => channel.identityChannel()),
      onSuccess: () => core.flatMap(core.write(chunk), () => loop)
    })(core.fromEffect(Queue.offer(queue, _take.chunk(chunk)))),
    onFailure: cause => core.foldCauseChannel({
      onFailure: () => core.failCause(cause),
      onSuccess: () => core.failCause(cause)
    })(core.fromEffect(Queue.offer(queue, _take.failCause(cause)))),
    onDone: () => core.foldCauseChannel({
      onFailure: () => core.unit,
      onSuccess: () => core.unit
    })(core.fromEffect(Queue.offer(queue, _take.end)))
  });
  return merge(execute(Effect.ensuring(Effect.zipRight(Queue.shutdown(queue), Deferred.succeed(deferred, void 0)))(run(right, sink))))(new StreamImpl(channel.ensuring(Effect.zipRight(Effect.forkDaemon(Queue.offer(queue, _take.end)), Deferred.await(deferred)))(core.pipeTo(toChannel(self), loop))));
})(fromEffect(Effect.all([Queue.bounded(1), Deferred.make()]))));
/** @internal */
export const throttle = /*#__PURE__*/dual(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: chunk => Effect.succeed(options.cost(chunk))
}));
/** @internal */
export const throttleEffect = /*#__PURE__*/dual(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
const throttleEnforceEffect = (self, cost, units, duration, burst) => {
  const loop = (tokens, timestampMillis) => core.readWithCause({
    onInput: input => channel.unwrap(Effect.map(([weight, currentTimeMillis]) => {
      const elapsed = currentTimeMillis - timestampMillis;
      const cycles = elapsed / Duration.toMillis(duration);
      const sum = tokens + cycles * units;
      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum < 0 ? max : Math.min(sum, max);
      if (weight <= available) {
        return core.flatMap(() => loop(available - weight, currentTimeMillis))(core.write(input));
      }
      return loop(tokens, timestampMillis);
    })(Effect.zip(Clock.currentTimeMillis)(cost(input)))),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  const throttled = channel.unwrap(Effect.map(currentTimeMillis => loop(units, currentTimeMillis))(Clock.currentTimeMillis));
  return new StreamImpl(channel.pipeToOrFail(throttled)(toChannel(self)));
};
const throttleShapeEffect = (self, costFn, units, duration, burst) => {
  const loop = (tokens, timestampMillis) => core.readWithCause({
    onInput: input => channel.unwrap(Effect.map(([weight, currentTimeMillis]) => {
      const elapsed = currentTimeMillis - timestampMillis;
      const cycles = elapsed / Duration.toMillis(duration);
      const sum = tokens + cycles * units;
      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum < 0 ? max : Math.min(sum, max);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay = Duration.millis(Math.max(0, waitCycles * Duration.toMillis(duration)));
      if (Duration.greaterThan(delay, Duration.zero)) {
        return core.flatMap(() => loop(remaining, currentTimeMillis))(channel.zipRight(core.write(input))(core.fromEffect(Clock.sleep(delay))));
      }
      return core.flatMap(core.write(input), () => loop(remaining, currentTimeMillis));
    })(Effect.zip(Clock.currentTimeMillis)(costFn(input)))),
    onFailure: core.failCause,
    onDone: () => core.unit
  });
  const throttled = channel.unwrap(Effect.map(currentTimeMillis => loop(units, currentTimeMillis))(Clock.currentTimeMillis));
  return new StreamImpl(channel.pipeToOrFail(throttled)(toChannel(self)));
};
/** @internal */
export const tick = interval => repeatWithSchedule(void 0, Schedule.spaced(interval));
/** @internal */
export const timeout = /*#__PURE__*/dual(2, (self, duration) => fromPull(Effect.map(Effect.timeoutFail({
  onTimeout: () => Option.none(),
  duration
}))(toPull(self))));
/** @internal */
export const timeoutFail = /*#__PURE__*/dual(3, (self, error, duration) => timeoutTo(duration, failSync(error))(self));
/** @internal */
export const timeoutFailCause = /*#__PURE__*/dual(3, (self, cause, duration) => fromPull(Effect.map(Effect.timeoutFailCause({
  onTimeout: () => Cause.map(cause(), Option.some),
  duration
}))(toPull(self))));
/** @internal */
export const timeoutTo = /*#__PURE__*/dual(3, (self, duration, that) => {
  const StreamTimeout = Cause.RuntimeException("Stream Timeout");
  return catchSomeCause(annotatedCause => {
    const cause = Cause.unannotate(annotatedCause);
    return Cause.isDieType(cause) && Cause.isRuntimeException(cause.defect) && cause.defect.message !== undefined && cause.defect.message === "Stream Timeout" ? Option.some(that) : Option.none();
  })(timeoutFailCause(() => Cause.die(StreamTimeout), duration)(self));
});
/** @internal */
export const toHub = /*#__PURE__*/dual(2, (self, capacity) => Effect.tap(hub => Effect.forkScoped(runIntoHubScoped(hub)(self)))(Effect.acquireRelease(Hub.bounded(capacity), hub => Hub.shutdown(hub))));
/** @internal */
export const toPull = self => Effect.map(channel.toPull(toChannel(self)), pull => Effect.flatMap(Either.match({
  onLeft: () => Effect.fail(Option.none()),
  onRight: Effect.succeed
}))(Effect.mapError(Option.some)(pull)));
/** @internal */
export const toQueue = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => Effect.tap(Effect.acquireRelease(options?.strategy === "unbounded" ? Queue.unbounded() : options?.strategy === "dropping" ? Queue.dropping(options.capacity ?? 2) : options?.strategy === "sliding" ? Queue.sliding(options.capacity ?? 2) : Queue.bounded(options?.capacity ?? 2), queue => Queue.shutdown(queue)), queue => Effect.forkScoped(runIntoQueueScoped(self, queue))));
/** @internal */
export const toQueueOfElements = /*#__PURE__*/dual(args => isStream(args[0]), (self, options) => Effect.tap(Effect.acquireRelease(Queue.bounded(options?.capacity ?? 2), queue => Queue.shutdown(queue)), queue => Effect.forkScoped(runIntoQueueElementsScoped(self, queue))));
/** @internal */
export const toReadableStream = source => {
  let pull;
  let scope;
  return new ReadableStream({
    start(controller) {
      scope = Effect.runSync(Scope.make());
      pull = Effect.asUnit(Effect.catchTags({
        "None": () => Effect.sync(() => {
          controller.close();
        }),
        "Some": error => Effect.sync(() => {
          controller.error(error.value);
        })
      })(Effect.tapErrorCause(() => Scope.close(scope, Exit.unit))(Effect.tap(chunk => Effect.sync(() => {
        Chunk.map(chunk, a => {
          controller.enqueue(a);
        });
      }))(Effect.runSync(Scope.use(scope)(toPull(source)))))));
    },
    pull() {
      return Effect.runPromise(pull);
    },
    cancel() {
      return Effect.runPromise(Scope.close(scope, Exit.unit));
    }
  });
};
/** @internal */
export const transduce = /*#__PURE__*/dual(2, (self, sink) => {
  const newChannel = core.suspend(() => {
    const leftovers = {
      ref: Chunk.empty()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer = core.suspend(() => {
      const leftover = leftovers.ref;
      if (Chunk.isEmpty(leftover)) {
        return core.readWith({
          onInput: input => core.flatMap(() => buffer)(core.write(input)),
          onFailure: core.fail,
          onDone: core.succeedNow
        });
      }
      leftovers.ref = Chunk.empty();
      return core.flatMap(() => buffer)(channel.writeChunk(leftover));
    });
    const concatAndGet = chunk => {
      const leftover = leftovers.ref;
      const concatenated = Chunk.appendAll(leftover, Chunk.filter(chunk, chunk => chunk.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = core.readWith({
      onInput: input => core.flatMap(core.write(input), () => upstreamMarker),
      onFailure: core.fail,
      onDone: done => channel.zipRight(core.sync(() => {
        upstreamDone.ref = true;
      }), core.succeedNow(done))
    });
    const transducer = core.flatMap(([leftover, z]) => core.flatMap(([done, newLeftovers]) => {
      const nextChannel = done && Chunk.isEmpty(newLeftovers) ? core.unit : transducer;
      return core.flatMap(() => nextChannel)(core.write(Chunk.of(z)));
    })(core.succeed([upstreamDone.ref, concatAndGet(leftover)])))(core.collectElements(_sink.toChannel(sink)));
    return channel.pipeToOrFail(transducer)(core.pipeTo(buffer)(core.pipeTo(upstreamMarker)(toChannel(self))));
  });
  return new StreamImpl(newChannel);
});
/** @internal */
export const unfold = (s, f) => unfoldChunk(s, s => Option.map(([a, s]) => [Chunk.of(a), s])(f(s)));
/** @internal */
export const unfoldChunk = (s, f) => {
  const loop = s => Option.match(f(s), {
    onNone: () => core.unit,
    onSome: ([chunk, s]) => core.flatMap(core.write(chunk), () => loop(s))
  });
  return new StreamImpl(core.suspend(() => loop(s)));
};
/** @internal */
export const unfoldChunkEffect = (s, f) => suspend(() => {
  const loop = s => channel.unwrap(Effect.map(f(s), Option.match({
    onNone: () => core.unit,
    onSome: ([chunk, s]) => core.flatMap(core.write(chunk), () => loop(s))
  })));
  return new StreamImpl(loop(s));
});
/** @internal */
export const unfoldEffect = (s, f) => unfoldChunkEffect(s, s => Effect.map(Option.map(([a, s]) => [Chunk.of(a), s]))(f(s)));
/** @internal */
export const unit = /*#__PURE__*/succeed(void 0);
/** @internal */
export const unwrap = effect => flatten(fromEffect(effect));
/** @internal */
export const unwrapScoped = effect => flatten(scoped(effect));
/** @internal */
export const updateService = /*#__PURE__*/dual(3, (self, tag, f) => contramapContext(context => Context.add(tag, f(Context.unsafeGet(tag)(context)))(context))(self));
/** @internal */
export const when = /*#__PURE__*/dual(2, (self, predicate) => whenEffect(Effect.sync(predicate))(self));
/** @internal */
export const whenCase = (evaluate, pf) => whenCaseEffect(pf)(Effect.sync(evaluate));
/** @internal */
export const whenCaseEffect = /*#__PURE__*/dual(2, (self, pf) => flatMap(a => Option.getOrElse(() => empty)(pf(a)))(fromEffect(self)));
/** @internal */
export const whenEffect = /*#__PURE__*/dual(2, (self, effect) => flatMap(bool => bool ? self : empty)(fromEffect(effect)));
/** @internal */
export const zip = /*#__PURE__*/dual(2, (self, that) => zipWith(that, (a, a2) => [a, a2])(self));
/** @internal */
export const zipFlatten = /*#__PURE__*/dual(2, (self, that) => zipWith(that, (a, a2) => [...a, a2])(self));
/** @internal */
export const zipAll = /*#__PURE__*/dual(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: a => [a, options.defaultOther],
  onOther: a2 => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
/** @internal */
export const zipAllLeft = /*#__PURE__*/dual(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: a => a
}));
/** @internal */
export const zipAllRight = /*#__PURE__*/dual(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
/** @internal */
export const zipAllSortedByKey = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: a => [a, options.defaultOther],
  onOther: a2 => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
/** @internal */
export const zipAllSortedByKeyLeft = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: a => a,
  order: options.order
}));
/** @internal */
export const zipAllSortedByKeyRight = /*#__PURE__*/dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
/** @internal */
export const zipAllSortedByKeyWith = /*#__PURE__*/dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipAllState.OP_DRAIN_LEFT:
        {
          return Effect.match({
            onFailure: Exit.fail,
            onSuccess: leftChunk => Exit.succeed([Chunk.map(leftChunk, ([k, a]) => [k, options.onSelf(a)]), ZipAllState.DrainLeft])
          })(pullLeft);
        }
      case ZipAllState.OP_DRAIN_RIGHT:
        {
          return Effect.match({
            onFailure: Exit.fail,
            onSuccess: rightChunk => Exit.succeed([Chunk.map(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), ZipAllState.DrainRight])
          })(pullRight);
        }
      case ZipAllState.OP_PULL_BOTH:
        {
          return Effect.matchEffect({
            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullBoth, pullLeft, pullRight);
                }
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed(merge(leftOption.value, rightOption.value)));
              }
              if (Option.isSome(leftOption) && Option.isNone(rightOption)) {
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipAllState.DrainLeft, pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed([Chunk.map(([k, a]) => [k, options.onSelf(a)])(leftOption.value), ZipAllState.DrainLeft]));
              }
              if (Option.isNone(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.DrainRight, pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed([Chunk.map(([k, a2]) => [k, options.onOther(a2)])(rightOption.value), ZipAllState.DrainRight]));
              }
              return Effect.succeed(Exit.fail(Option.none()));
            }
          })(Effect.zip(Effect.unsome(pullRight), {
            concurrent: true
          })(Effect.unsome(pullLeft)));
        }
      case ZipAllState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(([k, a2]) => [k, options.onOther(a2)])(state.rightChunk), ZipAllState.DrainRight])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: leftChunk => Chunk.isEmpty(leftChunk) ? pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(leftChunk, state.rightChunk)))
          });
        }
      case ZipAllState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), ZipAllState.DrainLeft])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: rightChunk => Chunk.isEmpty(rightChunk) ? pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(state.leftChunk, rightChunk)))
          });
        }
    }
  };
  const merge = (leftChunk, rightChunk) => {
    const hasNext = (chunk, index) => index < chunk.length - 1;
    const builder = [];
    let state = undefined;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
    let rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop = true;
    while (loop) {
      const compare = options.order(k1, k2);
      if (compare === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
          rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = ZipAllState.PullRight(Chunk.drop(leftIndex + 1)(leftChunk));
          loop = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = ZipAllState.PullLeft(Chunk.drop(rightIndex + 1)(rightChunk));
          loop = false;
        } else {
          state = ZipAllState.PullBoth;
          loop = false;
        }
      } else if (compare < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
            rightBuilder.push(rightTuple);
          }
          state = ZipAllState.PullLeft(Chunk.unsafeFromArray(rightBuilder));
          loop = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
            leftBuilder.push(leftTuple);
          }
          state = ZipAllState.PullRight(Chunk.unsafeFromArray(leftBuilder));
          loop = false;
        }
      }
    }
    return [Chunk.unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, ZipAllState.PullBoth, pull);
});
/** @internal */
export const zipAllWith = /*#__PURE__*/dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipAllState.OP_DRAIN_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: leftChunk => Effect.succeed(Exit.succeed([Chunk.map(leftChunk, options.onSelf), ZipAllState.DrainLeft]))
          });
        }
      case ZipAllState.OP_DRAIN_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: rightChunk => Effect.succeed(Exit.succeed([Chunk.map(rightChunk, options.onOther), ZipAllState.DrainRight]))
          });
        }
      case ZipAllState.OP_PULL_BOTH:
        {
          return Effect.matchEffect({
            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullBoth, pullLeft, pullRight);
                }
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value, options.onBoth)));
              }
              if (Option.isSome(leftOption) && Option.isNone(rightOption)) {
                return Effect.succeed(Exit.succeed([Chunk.map(leftOption.value, options.onSelf), ZipAllState.DrainLeft]));
              }
              if (Option.isNone(leftOption) && Option.isSome(rightOption)) {
                return Effect.succeed(Exit.succeed([Chunk.map(rightOption.value, options.onOther), ZipAllState.DrainRight]));
              }
              return Effect.succeed(Exit.fail(Option.none()));
            }
          })(Effect.zip(Effect.unsome(pullRight), {
            concurrent: true
          })(Effect.unsome(pullLeft)));
        }
      case ZipAllState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.rightChunk, options.onOther), ZipAllState.DrainRight])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: leftChunk => {
              if (Chunk.isEmpty(leftChunk)) {
                return pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.rightChunk)) {
                return pull(ZipAllState.PullRight(leftChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk, options.onBoth)));
            }
          });
        }
      case ZipAllState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.leftChunk, options.onSelf), ZipAllState.DrainLeft])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: rightChunk => {
              if (Chunk.isEmpty(rightChunk)) {
                return pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.leftChunk)) {
                return pull(ZipAllState.PullLeft(rightChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk, options.onBoth)));
            }
          });
        }
    }
  };
  const zip = (leftChunk, rightChunk, f) => {
    const [output, either] = zipChunks(leftChunk, rightChunk, f);
    switch (either._tag) {
      case "Left":
        {
          if (Chunk.isEmpty(either.left)) {
            return [output, ZipAllState.PullBoth];
          }
          return [output, ZipAllState.PullRight(either.left)];
        }
      case "Right":
        {
          if (Chunk.isEmpty(either.right)) {
            return [output, ZipAllState.PullBoth];
          }
          return [output, ZipAllState.PullLeft(either.right)];
        }
    }
  };
  return combineChunks(self, options.other, ZipAllState.PullBoth, pull);
});
/** @internal */
export const zipLatest = /*#__PURE__*/dual(2, (self, that) => zipLatestWith(that, (a, a2) => [a, a2])(self));
/** @internal */
export const zipLatestWith = /*#__PURE__*/dual(3, (self, that, f) => {
  const pullNonEmpty = pull => Effect.flatMap(chunk => Chunk.isEmpty(chunk) ? pullNonEmpty(pull) : Effect.succeed(chunk))(pull);
  return fromPull(Effect.flatMap(([left, right]) => toPull(flatMap(([l, r, leftFirst]) => flatMap(latest => concat(flatMap(fromChunk)(mapEffectSequential(Either.match({
    onLeft: leftChunk => Ref.modify(latest, ([_, rightLatest]) => [Chunk.map(a => f(a, rightLatest))(leftChunk), [Chunk.unsafeLast(leftChunk), rightLatest]]),
    onRight: rightChunk => Ref.modify(latest, ([leftLatest, _]) => [Chunk.map(a2 => f(leftLatest, a2))(rightChunk), [leftLatest, Chunk.unsafeLast(rightChunk)]])
  }))(mergeEither(repeatEffectOption(right))(repeatEffectOption(left)))))(fromChunk(leftFirst ? Chunk.map(a2 => f(Chunk.unsafeLast(l), a2))(r) : Chunk.map(a => f(a, Chunk.unsafeLast(r)))(l))))(fromEffect(Ref.make([Chunk.unsafeLast(l), Chunk.unsafeLast(r)]))))(fromEffectOption(Effect.raceWith(left, {
    other: right,
    onSelfDone: (leftDone, rightFiber) => Effect.zipWith(Fiber.join(rightFiber), (l, r) => [l, r, true])(Effect.suspend(() => leftDone)),
    onOtherDone: (rightDone, leftFiber) => Effect.zipWith(Fiber.join(leftFiber), (l, r) => [r, l, false])(Effect.suspend(() => rightDone))
  })))))(Effect.zip(Effect.map(pullNonEmpty)(toPull(that)))(Effect.map(pullNonEmpty)(toPull(self)))));
});
/** @internal */
export const zipLeft = /*#__PURE__*/dual(2, (self, that) => zipWithChunks(that, (left, right) => {
  if (left.length > right.length) {
    return [Chunk.take(right.length)(left), Either.left(Chunk.take(right.length)(left))];
  }
  return [left, Either.right(Chunk.drop(left.length)(right))];
})(self));
/** @internal */
export const zipRight = /*#__PURE__*/dual(2, (self, that) => zipWithChunks(that, (left, right) => {
  if (left.length > right.length) {
    return [right, Either.left(Chunk.take(right.length)(left))];
  }
  return [Chunk.take(left.length)(right), Either.right(Chunk.drop(left.length)(right))];
})(self));
/** @internal */
export const zipWith = /*#__PURE__*/dual(3, (self, that, f) => zipWithChunks(that, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))(self));
/** @internal */
export const zipWithChunks = /*#__PURE__*/dual(3, (self, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipChunksState.OP_PULL_BOTH:
        {
          return Effect.matchEffect({
            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipChunksState.PullBoth, pullLeft, pullRight);
                }
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipChunksState.PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipChunksState.PullRight(leftOption.value), pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value)));
              }
              return Effect.succeed(Exit.fail(Option.none()));
            }
          })(Effect.zip(Effect.unsome(pullRight), {
            concurrent: true
          })(Effect.unsome(pullLeft)));
        }
      case ZipChunksState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: leftChunk => {
              if (Chunk.isEmpty(leftChunk)) {
                return pull(ZipChunksState.PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.rightChunk)) {
                return pull(ZipChunksState.PullRight(leftChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk)));
            }
          });
        }
      case ZipChunksState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: rightChunk => {
              if (Chunk.isEmpty(rightChunk)) {
                return pull(ZipChunksState.PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.leftChunk)) {
                return pull(ZipChunksState.PullLeft(rightChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk)));
            }
          });
        }
    }
  };
  const zip = (leftChunk, rightChunk) => {
    const [output, either] = f(leftChunk, rightChunk);
    switch (either._tag) {
      case "Left":
        {
          if (Chunk.isEmpty(either.left)) {
            return [output, ZipChunksState.PullBoth];
          }
          return [output, ZipChunksState.PullRight(either.left)];
        }
      case "Right":
        {
          if (Chunk.isEmpty(either.right)) {
            return [output, ZipChunksState.PullBoth];
          }
          return [output, ZipChunksState.PullLeft(either.right)];
        }
    }
  };
  return combineChunks(that, ZipChunksState.PullBoth, pull)(self);
});
/** @internal */
export const zipWithIndex = self => mapAccum(0, (index, a) => [index + 1, [a, index]])(self);
/** @internal */
export const zipWithNext = self => {
  const process = last => core.readWithCause({
    onInput: input => {
      const [newLast, chunk] = Chunk.mapAccum(input, last, (prev, curr) => [Option.some(curr), Option.map(a => [a, curr])(prev)]);
      const output = Chunk.filterMap(chunk, option => Option.isSome(option) ? Option.some([option.value[0], Option.some(option.value[1])]) : Option.none());
      return core.flatMap(core.write(output), () => process(newLast));
    },
    onFailure: core.failCause,
    onDone: () => Option.match(last, {
      onNone: () => core.unit,
      onSome: value => channel.zipRight(core.write(Chunk.of([value, Option.none()])), core.unit)
    })
  });
  return new StreamImpl(channel.pipeToOrFail(process(Option.none()))(toChannel(self)));
};
/** @internal */
export const zipWithPrevious = self => mapAccum(Option.none(), (prev, curr) => [Option.some(curr), [prev, curr]])(self);
/** @internal */
export const zipWithPreviousAndNext = self => map(([[prev, curr], next]) => [prev, curr, Option.map(tuple => tuple[1])(next)])(zipWithNext(zipWithPrevious(self)));
/** @internal */
const zipChunks = (left, right, f) => {
  if (left.length > right.length) {
    return [Chunk.zipWith(right, f)(Chunk.take(right.length)(left)), Either.left(Chunk.drop(right.length)(left))];
  }
  return [Chunk.zipWith(Chunk.take(left.length)(right), f)(left), Either.right(Chunk.drop(left.length)(right))];
};
// Do notation
/** @internal */
export const Do = /*#__PURE__*/succeed({});
/** @internal */
export const bind = /*#__PURE__*/dual(args => typeof args[0] !== "string", (self, tag, f, options) => flatMap(self, k => map(f(k), a => ({
  ...k,
  [tag]: a
})), options));
/* @internal */
export const bindTo = /*#__PURE__*/dual(2, (self, tag) => map(self, a => ({
  [tag]: a
})));
/* @internal */
export const let_ = /*#__PURE__*/dual(3, (self, tag, f) => map(self, k => ({
  ...k,
  [tag]: f(k)
})));
// Circular with Channel
/** @internal */
export const channelToStream = self => {
  return new StreamImpl(self);
};
//# sourceMappingURL=stream.mjs.map